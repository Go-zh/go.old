<!--{
	"Title": "实效Go编程",
	"Subtitle": "版本：2013年12月22日",
	"Template": true
}-->

<!--{
	"Title": "Effective Go",
	"Subtitle": "Version of Nov 13, 2013",
	"Template": true
}-->

<div class="english">
<h2 id="introduction">Introduction</h2>
</div>

<h2 id="简介">简介</h2>

<div class="english">
<p>
Go is a new language.  Although it borrows ideas from
existing languages,
it has unusual properties that make effective Go programs
different in character from programs written in its relatives.
A straightforward translation of a C++ or Java program into Go
is unlikely to produce a satisfactory result&mdash;Java programs
are written in Java, not Go.
On the other hand, thinking about the problem from a Go
perspective could produce a successful but quite different
program.
In other words,
to write Go well, it's important to understand its properties
and idioms.
It's also important to know the established conventions for
programming in Go, such as naming, formatting, program
construction, and so on, so that programs you write
will be easy for other Go programmers to understand.
</p>
</div>

<p>
Go 是一门全新的语言。尽管它从既有的语言中借鉴了许多理念，但其与众不同的特性，
使得使用Go编程在本质上就不同于其它语言。将现有的C++或Java程序直译为Go
程序并不能令人满意——毕竟Java程序是用Java编写的，而不是Go。
另一方面，若从Go的角度去分析问题，你就能编写出同样可行但大不相同的程序。
换句话说，要想将Go程序写得好，就必须理解其特性和风格。了解命名、格式化、
程序结构等既定规则也同样重要，这样你编写的程序才能更容易被其他程序员所理解。
</p>

<div class="english">
<p>
This document gives tips for writing clear, idiomatic Go code.
It augments the <a href="/ref/spec">language specification</a>,
the <a href="http://tour.golang.org/">Tour of Go</a>,
and <a href="/doc/code.html">How to Write Go Code</a>,
all of which you
should read first.
</p>
</div>

<p>
本文档就如何编写清晰、地道的Go代码提供了一些技巧。它是对<a href="/ref/spec">语言规范</a>、
<a href="https://go-tour-zh.appspot.com/">Go语言之旅</a>以及
<a href="/doc/code.html">如何使用Go编程</a>的补充说明，因此我们建议您先阅读这些文档。
</p>

<div class="english">
<h3 id="examples">Examples</h3>
</div>

<h3 id="示例">示例</h3>

<div class="english">
<p>
The <a href="/src/pkg/">Go package sources</a>
are intended to serve not
only as the core library but also as examples of how to
use the language.
Moreover, many of the packages contain working, self-contained
executable examples you can run directly from the
<a href="http://golang.org">golang.org</a> web site, such as
<a href="http://golang.org/pkg/strings/#example_Map">this one</a> (if
necessary, click on the word "Example" to open it up).
If you have a question about how to approach a problem or how something
might be implemented, the documentation, code and examples in the
library can provide answers, ideas and
background.
</p>
</div>

<p>
<a href="/src/pkg/">Go包的源码</a>不仅是核心库，同时也是学习如何使用Go语言的示例源码。
此外，其中的一些包还包含了可工作的，独立的可执行示例，你可以直接在
<a href="http://golang.org">golang.org</a>网站上运行它们，比如
<a href="http://zh.golanger.com/pkg/strings/#example_Map">这个例子</a>
（单击文字“示例”来展开它）。如果你有任何关于某些问题如何解决，或某些东西如何实现的疑问，
也可以从中获取相关的答案、思路以及后台实现。
</p>


<div class="english">
<h2 id="formatting">Formatting</h2>
</div>

<h2 id="格式化">格式化</h2>

<div class="english">
<p>
Formatting issues are the most contentious
but the least consequential.
People can adapt to different formatting styles
but it's better if they don't have to, and
less time is devoted to the topic
if everyone adheres to the same style.
The problem is how to approach this Utopia without a long
prescriptive style guide.
</p>
</div>

<p>
格式化问题总是充满了争议，但却始终没有形成统一的定论。虽说人们可以适应不同的编码风格，
但抛弃这种适应过程岂不更好？若所有人都遵循相同的编码风格，在这类问题上浪费的时间将会更少。
问题就在于如何实现这种设想，而无需冗长的语言风格规范。
</p>

<div class="english">
<p>
With Go we take an unusual
approach and let the machine
take care of most formatting issues.
The <code>gofmt</code> program
(also available as <code>go fmt</code>, which
operates at the package level rather than source file level)
reads a Go program
and emits the source in a standard style of indentation
and vertical alignment, retaining and if necessary
reformatting comments.
If you want to know how to handle some new layout
situation, run <code>gofmt</code>; if the answer doesn't
seem right, rearrange your program (or file a bug about <code>gofmt</code>),
don't work around it.
</p>
</div>

<p>
在Go中我们另辟蹊径，让机器来处理大部分的格式化问题。<code>gofmt</code>
程序（也可用 <code>go fmt</code>，它以包为处理对象而非源文件）将Go程序按照标准风格缩进、
对齐，保留注释并在需要时重新格式化。若你想知道如何处理一些新的代码布局，请尝试运行
<code>gofmt</code>；若结果仍不尽人意，请重新组织你的程序（或提交有关 <code>gofmt</code>
的Bug），而不必为此纠结。
</p>

<div class="english">
<p>
As an example, there's no need to spend time lining up
the comments on the fields of a structure.
<code>Gofmt</code> will do that for you.  Given the
declaration
</p>
</div>

<p>
举例来说，你无需花时间将结构体中的字段注释对齐，<code>gofmt</code> 将为你代劳。
假如有以下声明：
</p>

<div class="english">
<pre>
type T struct {
	name string // name of the object
	value int // its value
}
</pre>
</div>

<pre>
type T struct {
	name string // 对象名
	value int // 对象值
}
</pre>

<div class="english">
<p>
<code>gofmt</code> will line up the columns:
</p>
</div>

<p>
<code>gofmt</code> 会将它按列对齐为：
</p>

<div class="english">
<pre>
type T struct {
	name    string // name of the object
	value   int    // its value
}
</pre>
</div>

<pre>
type T struct {
	name    string // 对象名
	value   int    // 对象值
}
</pre>

<div class="english">
<p>
All Go code in the standard packages has been formatted with <code>gofmt</code>.
</p>
</div>

<p>
标准包中所有的Go代码都已经用 <code>gofmt</code> 格式化过了。
</p>

<div class="english">
<p>
Some formatting details remain.  Very briefly:
</p>
</div>

<p>
还有一些关于格式化的细节，它们非常简短：
</p>

<div class="english">
<dl>
	<dt>Indentation</dt>
	<dd>We use tabs for indentation and <code>gofmt</code> emits them by default.
	Use spaces only if you must.
	</dd>
	<dt>Line length</dt>
	<dd>
	Go has no line length limit.  Don't worry about overflowing a punched card.
	If a line feels too long, wrap it and indent with an extra tab.
	</dd>
	<dt>Parentheses</dt>
	<dd>
	Go needs fewer parentheses than C and Java: control structures (<code>if</code>,
	<code>for</code>, <code>switch</code>) do not have parentheses in
	their syntax.
	Also, the operator precedence hierarchy is shorter and clearer, so
<pre>
x&lt;&lt;8 + y&lt;&lt;16
</pre>
	means what the spacing implies, unlike in the other languages.
	</dd>
</dl>
</div>

<dl>
	<dt>缩进</dt>
	<dd>
	我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。在你认为确实有必要时再使用空格。
	</dd>
	<dt>行的长度</dt>
	<dd>
	Go对行的长度没有限制，别担心打孔纸不够长。如果一行实在太长，也可进行折行并插入适当的tab缩进。
	</dd>
	<dt>括号</dt>
	<dd>
	比起C和Java，Go所需的括号更少：控制结构（<code>if</code>、<code>for</code> 和
	<code>switch</code>）在语法上并不需要圆括号。此外，操作符优先级处理变得更加简洁，因此
<pre>
x&lt;&lt;8 + y&lt;&lt;16
</pre>
	正表述了空格符所传达的含义。
	</dd>
</dl>

<div class="english">
<h2 id="commentary">Commentary</h2>
</div>

<h2 id="注释">注释</h2>

<div class="english">
<p>
Go provides C-style <code>/* */</code> block comments
and C++-style <code>//</code> line comments.
Line comments are the norm;
block comments appear mostly as package comments, but
are useful within an expression or to disable large swaths of code.
</p>
</div>

<p>
Go语言支持C风格的块注释 <code>/* */</code> 和C++风格的行注释 <code>//</code>。
行注释更为常用，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。
</p>

<div class="english">
<p>
The program—and web server—<code>godoc</code> processes
Go source files to extract documentation about the contents of the
package.
Comments that appear before top-level declarations, with no intervening newlines,
are extracted along with the declaration to serve as explanatory text for the item.
The nature and style of these comments determines the
quality of the documentation <code>godoc</code> produces.
</p>
</div>

<p>
<code>godoc</code> 既是一个程序，又是一个Web服务器，它对Go的源码进行处理，并提取包中的文档内容。
出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提取出来，作为该条目的说明文档。
这些注释的类型和风格决定了 <code>godoc</code> 生成的文档质量。
</p>

<div class="english">
<p>
Every package should have a <i>package comment</i>, a block
comment preceding the package clause.
For multi-file packages, the package comment only needs to be
present in one file, and any one will do.
The package comment should introduce the package and
provide information relevant to the package as a whole.
It will appear first on the <code>godoc</code> page and
should set up the detailed documentation that follows.
</p>
</div>

<p>
每个包都应包含一段<b>包注释</b>，即放置在包子句前的一个块注释。对于包含多个文件的包，
包注释只需出现在其中的任一文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。
它将出现在 <code>godoc</code> 页面中的最上面，并为紧随其后的内容建立详细的文档。
</p>

<div class="english">
<pre>
/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

	regexp:
		concatenation { '|' concatenation }
	concatenation:
		{ closure }
	closure:
		term [ '*' | '+' | '?' ]
	term:
		'^'
		'$'
		'.'
		character
		'[' [ '^' ] character-ranges ']'
		'(' regexp ')'
*/
package regexp
</pre>
</div>

<pre>
/*
	regexp 包为正则表达式实现了一个简单的库。

	该库接受的正则表达式语法为：

	正则表达式:
		串联 { '|' 串联 }
	串联:
		{ 闭包 }
	闭包:
		条目 [ '*' | '+' | '?' ]
	条目:
		'^'
		'$'
		'.'
		字符
		'[' [ '^' ] 字符遍历 ']'
		'(' 正则表达式 ')'
*/
package regexp
</pre>

<div class="english">
<p>
If the package is simple, the package comment can be brief.
</p>
</div>

<p>
若某个包比较简单，包注释同样可以简洁些。
</p>

<div class="english">
<pre>
// Package path implements utility routines for
// manipulating slash-separated filename paths.
</pre>
</div>

<pre>
// path 包实现了一些常用的工具，以便于操作用反斜杠分隔的路径.
</pre>

<div class="english">
<p>
Comments do not need extra formatting such as banners of stars.
The generated output may not even be presented in a fixed-width font, so don't depend
on spacing for alignment&mdash;<code>godoc</code>, like <code>gofmt</code>,
takes care of that.
The comments are uninterpreted plain text, so HTML and other
annotations such as <code>_this_</code> will reproduce <i>verbatim</i> and should
not be used.
One adjustment <code>godoc</code> does do is to display indented
text in a fixed-width font, suitable for program snippets.
The package comment for the
<a href="http://golang.org/pkg/fmt/"><code>fmt</code> package</a> uses this to good effect.
</p>
</div>

<p>
注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示，
因此不要依赖于空格对齐，<code>godoc</code> 会像 <code>gofmt</code> 那样处理好这一切。
注释是不会被解析的纯文本，因此像HTML或其它类似于 <code>_这样_</code> 的东西将按照
<b>原样</b> 输出，因此不应使用它们。<code>godoc</code> 所做的调整，
就是将已缩进的文本以等宽字体显示，来适应对应的程序片段。
<a href="http://golang.org/pkg/fmt/"><code>fmt</code> 包</a>的注释就用了这种不错的效果。
</p>

<div class="english">
<p>
Depending on the context, <code>godoc</code> might not even
reformat comments, so make sure they look good straight up:
use correct spelling, punctuation, and sentence structure,
fold long lines, and so on.
</p>
</div>

<p>
<code>godoc</code> 是否会重新格式化注释取决于上下文，因此必须确保它们看起来清晰易辨：
使用正确的拼写、标点和语句结构以及折叠长行等。
</p>

<div class="english">
<p>
Inside a package, any comment immediately preceding a top-level declaration
serves as a <i>doc comment</i> for that declaration.
Every exported (capitalized) name in a program should
have a doc comment.
</p>
</div>

<p>
在包中，任何顶级声明前面的注释都将作为该声明的<b>文档注释</b>。
在程序中，每个可导出（首字母大写）的名称都应该有文档注释。
</p>

<div class="english">
<p>
Doc comments work best as complete sentences, which allow
a wide variety of automated presentations.
The first sentence should be a one-sentence summary that
starts with the name being declared.
</p>
</div>

<p>
文档注释最好是完整的句子，这样它才能适应各种自动化的展示。
第一句应当以被声明的东西开头，并且是单句的摘要。
</p>

<div class="english">
<pre>
// Compile parses a regular expression and returns, if successful, a Regexp
// object that can be used to match against text.
func Compile(str string) (regexp *Regexp, err error) {
</pre>
</div>

<pre>
// Compile 用于解析正则表达式并返回，如果成功，则 Regexp 对象就可用于匹配所针对的文本。
func Compile(str string) (regexp *Regexp, err error) {
</pre>

<div class="english">
<p>
If the name always begins the comment, the output of <code>godoc</code>
can usefully be run through <code>grep</code>.
Imagine you couldn't remember the name "Compile" but were looking for
the parsing function for regular expressions, so you ran
the command,
</p>
</div>

<p>
若注释总是以名称开头，<code>godoc</code> 的输出就能通过 <code>grep</code>
变得更加有用。假如你记不住“Compile”这个名称，而又在找正则表达式的解析函数，
那就可以运行
</p>

<pre>
$ godoc regexp | grep parse
</pre>

<div class="english">
<p>
If all the doc comments in the package began, "This function...", <code>grep</code>
wouldn't help you remember the name. But because the package starts each
doc comment with the name, you'd see something like this,
which recalls the word you're looking for.
</p>
</div>

<p>
若包中的所有文档注释都以“此函数…”开头，<code>grep</code> 就无法帮你记住此名称。
但由于每个包的文档注释都以其名称开头，你就能看到这样的内容，它能显示你正在寻找的词语。
</p>

<div class="english">
<pre>
$ godoc regexp | grep parse
	Compile parses a regular expression and returns, if successful, a Regexp
	parsed. It simplifies safe initialization of global variables holding
	cannot be parsed. It simplifies safe initialization of global variables
$
</pre>
</div>

<pre>
$ godoc regexp | grep parse
	Compile parses a regular expression and returns, if successful, a Regexp
	parsed. It simplifies safe initialization of global variables holding
	cannot be parsed. It simplifies safe initialization of global variables
$
</pre>

<div class="english">
<p>
Go's declaration syntax allows grouping of declarations.
A single doc comment can introduce a group of related constants or variables.
Since the whole declaration is presented, such a comment can often be perfunctory.
</p>
</div>

<p>
Go的声明语法允许成组声明。单个文档注释应介绍一组相关的常量或变量。
由于是整体声明，这种注释往往较为笼统。
</p>

<div class="english">
<pre>
// Error codes returned by failures to parse an expression.
var (
	ErrInternal      = errors.New("regexp: internal error")
	ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
	ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
	...
)
</pre>
</div>

<pre>
// 表达式解析失败后返回错误代码。
var (
	ErrInternal      = errors.New("regexp: internal error")
	ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
	ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
	...
)
</pre>

<div class="english">
<p>
Even for private names, grouping can also indicate relationships between items,
such as the fact that a set of variables is protected by a mutex.
</p>
</div>

<p>
即便是对于私有名称，也可通过成组声明来表明各项间的关系，例如某一组由互斥体保护的变量。
</p>

<pre>
var (
	countLock   sync.Mutex
	inputCount  uint32
	outputCount uint32
	errorCount  uint32
)
</pre>

<div class="english">
<h2 id="names">Names</h2>
</div>

<h2 id="命名">命名</h2>

<div class="english">
<p>
Names are as important in Go as in any other language.
They even have semantic effect:
the visibility of a name outside a package is determined by whether its
first character is upper case.
It's therefore worth spending a little time talking about naming conventions
in Go programs.
</p>
</div>

<p>
正如命名在其它语言中的地位，它在 Go 中同样重要。有时它们甚至会影响语义：
例如，某个名称在包外是否可见，就取决于其首个字符是否为大写字母。
因此有必要花点时间来讨论Go程序中的命名约定。
</p>


<div class="english">
<h3 id="package-names">Package names</h3>
</div>

<h3 id="包名">包名</h3>

<div class="english">
<p>
When a package is imported, the package name becomes an accessor for the
contents.  After
</p>
</div>

<p>
当一个包被导入后，包名就会成了内容的访问器。在
</p>

<pre>
import "bytes"
</pre>

<div class="english">
<p>
the importing package can talk about <code>bytes.Buffer</code>.  It's
helpful if everyone using the package can use the same name to refer to
its contents, which implies that the package name should be good:
short, concise, evocative.  By convention, packages are given
lower case, single-word names; there should be no need for underscores
or mixedCaps.
Err on the side of brevity, since everyone using your
package will be typing that name.
And don't worry about collisions <i>a priori</i>.
The package name is only the default name for imports; it need not be unique
across all source code, and in the rare case of a collision the
importing package can choose a different name to use locally.
In any case, confusion is rare because the file name in the import
determines just which package is being used.
</p>
</div>

<p>
之后，被导入的包就能通过 <code>bytes.Buffer</code> 来引用了。
若所有人都以相同的名称来引用其内容将大有裨益，
这也就意味着包应当有个恰当的名称：其名称应该简洁明了而易于理解。按照惯例，
包应当以小写的单个单词来命名，且不应使用下划线或驼峰记法。<code>err</code>
的命名就是出于简短考虑的，因为任何使用该包的人都会键入该名称。
不必担心<b>引用次序</b>的冲突。包名就是导入时所需的唯一默认名称，
它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下，
也可为导入的包选择一个别名来局部使用。
无论如何，通过文件名来判定使用的包，都是不会产生混淆的。
</p>

<div class="english">
<p>
Another convention is that the package name is the base name of
its source directory;
the package in <code>src/pkg/encoding/base64</code>
is imported as <code>"encoding/base64"</code> but has name <code>base64</code>,
not <code>encoding_base64</code> and not <code>encodingBase64</code>.
</p>
</div>

<p>
另一个约定就是包名应为其源码目录的基本名称。在 <code>src/pkg/encoding/base64</code>
中的包应作为 <code>"encoding/base64"</code> 导入，其包名应为 <code>base64</code>，
而非 <code>encoding_base64</code> 或 <code>encodingBase64</code>。
</p>

<div class="english">
<p>
The importer of a package will use the name to refer to its contents.
so exported names in the package can use that fact
to avoid stutter.
(Don't use the <code>import .</code> notation, which can simplify
tests that must run outside the package they are testing, but should otherwise be avoided.)
For instance, the buffered reader type in the <code>bufio</code> package is called <code>Reader</code>,
not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>,
which is a clear, concise name.
Moreover,
because imported entities are always addressed with their package name, <code>bufio.Reader</code>
does not conflict with <code>io.Reader</code>.
Similarly, the function to make new instances of <code>ring.Ring</code>&mdash;which
is the definition of a <em>constructor</em> in Go&mdash;would
normally be called <code>NewRing</code>, but since
<code>Ring</code> is the only type exported by the package, and since the
package is called <code>ring</code>, it's called just <code>New</code>,
which clients of the package see as <code>ring.New</code>.
Use the package structure to help you choose good names.
</p>
</div>

<p>
包的导入者可通过包名来引用其内容，因此包中的可导出名称可以此来避免冲突。
（请勿使用 <code>import .</code> 记法，它可以简化必须在被测试包外运行的测试，
除此之外应尽量避免使用。）例如，<code>bufio</code> 包中的缓存读取器类型叫做
<code>Reader</code> 而非 <code>BufReader</code>，因为用户将它看做
<code>bufio.Reader</code>，这是个清楚而简洁的名称。
此外，由于被导入的项总是通过它们的包名来确定，因此 <code>bufio.Reader</code>
不会与 <code>io.Reader</code> 发生冲突。同样，用于创建 <code>ring.Ring</code>
的新实例的函数（这就是Go中的<strong>构造函数</strong>）一般会称之为
<code>NewRing</code>，但由于 <code>Ring</code> 是该包所导出的唯一类型，且该包也叫
<code>ring</code>，因此它可以只叫做 <code>New</code>，它跟在包的后面，就像
<code>ring.New</code>。使用包结构可以帮助你选择好的名称。
</p>

<div class="english">
<p>
Another short example is <code>once.Do</code>;
<code>once.Do(setup)</code> reads well and would not be improved by
writing <code>once.DoOrWaitUntilDone(setup)</code>.
Long names don't automatically make things more readable.
A helpful doc comment can often be more valuable than an extra long name.
</p>
</div>

<p>
另一个简短的例子是 <code>once.Do</code>，<code>once.Do(setup)</code> 表述足够清晰，
使用 <code>once.DoOrWaitUntilDone(setup)</code> 完全就是画蛇添足。
长命名并不会使其更具可读性。一份有用的说明文档通常比额外的长名更有价值。
</p>

<div class="english">
<h3 id="Getters">Getters</h3>
</div>

<h3 id="获取器">获取器</h3>

<div class="english">
<p>
Go doesn't provide automatic support for getters and setters.
There's nothing wrong with providing getters and setters yourself,
and it's often appropriate to do so, but it's neither idiomatic nor necessary
to put <code>Get</code> into the getter's name.  If you have a field called
<code>owner</code> (lower case, unexported), the getter method should be
called <code>Owner</code> (upper case, exported), not <code>GetOwner</code>.
The use of upper-case names for export provides the hook to discriminate
the field from the method.
A setter function, if needed, will likely be called <code>SetOwner</code>.
Both names read well in practice:
</p>
</div>

<p>
Go并不对获取器（getter）和设置器（setter）提供自动支持。
你应当自己提供获取器和设置器，通常很值得这样做，但若要将 <code>Get</code>
放到获取器的名字中，既不符合习惯，也没有必要。若你有个名为 <code>owner</code>
（小写，未导出）的字段，其获取器应当名为 <code>Owner</code>（大写，可导出）而非
<code>GetOwner</code>。大写字母即为可导出的这种规定为区分方法和字段提供了便利。
若要提供设置器方法，<code>SetOwner</code> 是个不错的选择。两个命名看起来都很合理：
</p>

<pre>
owner := obj.Owner()
if owner != user {
	obj.SetOwner(user)
}
</pre>

<div class="english">
<h3 id="interface-names">Interface names</h3>
</div>

<h3 id="接口名">接口名</h3>

<div class="english">
<p>
By convention, one-method interfaces are named by
the method name plus an -er suffix or similar modification
to construct an agent noun: <code>Reader</code>,
<code>Writer</code>, <code>Formatter</code>,
<code>CloseNotifier</code> etc.
</p>
</div>

<p>
按照约定，只包含一个方法的接口应当以该方法的名称加上-er后缀来命名，如
<code>Reader</code>、<code>Writer</code>、
<code>Formatter</code>、<code>CloseNotifier</code> 等。
</p>

<div class="english">
<p>
There are a number of such names and it's productive to honor them and the function
names they capture.
<code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>,
<code>String</code> and so on have
canonical signatures and meanings.  To avoid confusion,
don't give your method one of those names unless it
has the same signature and meaning.
Conversely, if your type implements a method with the
same meaning as a method on a well-known type,
give it the same name and signature;
call your string-converter method <code>String</code> not <code>ToString</code>.
</p>
</div>

<p>
诸如此类的命名有很多，遵循它们及其代表的函数名会让事情变得简单。
<code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、
<code>String</code> 等都具有典型的签名和意义。为避免冲突，请不要用这些名称为你的方法命名，
除非你明确知道它们的签名和意义相同。反之，若你的类型实现了的方法，
与一个众所周知的类型的方法拥有相同的含义，那就使用相同的命名。
请将字符串转换方法命名为 <code>String</code> 而非 <code>ToString</code>。
</p>

<div class="english">
<h3 id="mixed-caps">MixedCaps</h3>
</div>

<h3 id="驼峰记法">驼峰记法</h3>

<div class="english">
<p>
Finally, the convention in Go is to use <code>MixedCaps</code>
or <code>mixedCaps</code> rather than underscores to write
multiword names.
</p>
</div>

<p>
最后，Go中约定使用驼峰记法 <code>MixedCaps</code> 或 <code>mixedCaps</code>。
</p>

<div class="english">
<h2 id="semicolons">Semicolons</h2>
</div>

<h2 id="分号">分号</h2>

<div class="english">
<p>
Like C, Go's formal grammar uses semicolons to terminate statements,
but unlike in C, those semicolons do not appear in the source.
Instead the lexer uses a simple rule to insert semicolons automatically
as it scans, so the input text is mostly free of them.
</p>
</div>

<p>
和C一样，Go的正式语法使用分号来结束语句；和C不同的是，这些分号并不在源码中出现。
取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此因此源码中基本就不用分号了。
</p>

<div class="english">
<p>
The rule is this. If the last token before a newline is an identifier
(which includes words like <code>int</code> and <code>float64</code>),
a basic literal such as a number or string constant, or one of the
tokens
</p>
</div>

<p>
规则是这样的：若在新行前的最后一个标记为标识符（包括 <code>int</code> 和
<code>float64</code> 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一
</p>

<pre>
break continue fallthrough return ++ -- ) }
</pre>

<div class="english">
<p>
the lexer always inserts a semicolon after the token.
This could be summarized as, &ldquo;if the newline comes
after a token that could end a statement, insert a semicolon&rdquo;.
</p>
</div>

<p>
则词法分析将始终在该标记后面插入分号。这点可以概括为：
“如果新行前的标记为语句的末尾，则插入分号”。
</p>

<div class="english">
<p>
A semicolon can also be omitted immediately before a closing brace,
so a statement such as
</p>
</div>

<p>
分号也可在闭括号之前直接省略，因此像
</p>

<pre>
	go func() { for { dst &lt;- &lt;-src } }()
</pre>

<div class="english">
<p>
needs no semicolons.
Idiomatic Go programs have semicolons only in places such as
<code>for</code> loop clauses, to separate the initializer, condition, and
continuation elements.  They are also necessary to separate multiple
statements on a line, should you write code that way.
</p>
</div>

<p>
这样的语句无需分号。通常Go程序只在诸如 <code>for</code> 循环子句这样的地方使用分号，
以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。
</p>

<div class="english">
<p>
One consequence of the semicolon insertion rules
is that you cannot put the opening brace of a
control structure (<code>if</code>, <code>for</code>, <code>switch</code>,
or <code>select</code>) on the next line.  If you do, a semicolon
will be inserted before the brace, which could cause unwanted
effects.  Write them like this
</p>
</div>

<p>
警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code>
或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号前面插入一个分号，这可能引起不需要的效果。
你应该这样写
</p>

<div class="english">
<pre>
if i &lt; f() {
	g()
}
</pre>
<p>
not like this
</p>
<pre>
if i &lt; f()  // wrong!
{           // wrong!
	g()
}
</pre>
</div>

<pre>
if i &lt; f() {
	g()
}
</pre>
<p>
而不是这样
</p>
<pre>
if i &lt; f()  // 错！
{           // 错！
	g()
}
</pre>


<div class="english">
<h2 id="control-structures">Control structures</h2>
</div>

<h2 id="控制结构">控制结构</h2>

<div class="english">
<p>
The control structures of Go are related to those of C but differ
in important ways.
There is no <code>do</code> or <code>while</code> loop, only a
slightly generalized
<code>for</code>;
<code>switch</code> is more flexible;
<code>if</code> and <code>switch</code> accept an optional
initialization statement like that of <code>for</code>;
<code>break</code> and <code>continue</code> statements
take an optional label to identify what to break or continue;
and there are new control structures including a type switch and a
multiway communications multiplexer, <code>select</code>.
The syntax is also slightly different:
there are no parentheses
and the bodies must always be brace-delimited.
</p>
</div>

<p>
Go中的结构控制与C有许多相似之处，但其不同之处才是独到之处。
Go不再使用 <code>do</code> 或 <code>while</code> 循环，只有一个更通用的
<code>for</code>；<code>switch</code> 要更灵活一点；<code>if</code> 和
<code>switch</code> 像 <code>for</code>一样可接受可选的初始化语句；
此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。
其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。
</p>

<h3 id="if">If</h3>

<div class="english">
<p>
In Go a simple <code>if</code> looks like this:
</p>
</div>

<p>
在Go中，一个简单的 <code>if</code> 语句看起来像这样：
</p>

<pre>
if x &gt; 0 {
	return y
}
</pre>

<div class="english">
<p>
Mandatory braces encourage writing simple <code>if</code> statements
on multiple lines.  It's good style to do so anyway,
especially when the body contains a control statement such as a
<code>return</code> or <code>break</code>.
</p>
</div>

<p>
强制的大括号促使你将简单的 <code>if</code> 语句分成多行。特别是在主体中包含
<code>return</code> 或 <code>break</code> 等控制语句时，这种编码风格的好处一比便知。
</p>

<div class="english">
<p>
Since <code>if</code> and <code>switch</code> accept an initialization
statement, it's common to see one used to set up a local variable.
</p>
</div>

<p>
由于 <code>if</code> 和 <code>switch</code> 可接受初始化语句，
因此用它们来设置局部变量十分常见。
</p>

<pre>
if err := file.Chmod(0664); err != nil {
	log.Print(err)
	return err
}
</pre>

<div class="english">
<p id="else">
In the Go libraries, you'll find that
when an <code>if</code> statement doesn't flow into the next statement—that is,
the body ends in <code>break</code>, <code>continue</code>,
<code>goto</code>, or <code>return</code>—the unnecessary
<code>else</code> is omitted.
</p>
</div>

<p id="else">
在Go的库中，你会发现若 <code>if</code> 语句不会执行到下一条语句时，亦即其执行体
以 <code>break</code>、<code>continue</code>、<code>goto</code> 或
<code>return</code> 结束时，不必要的 <code>else</code> 会被省略。
</p>

<pre>
f, err := os.Open(name)
if err != nil {
	return err
}
codeUsing(f)
</pre>

<div class="english">
<p>
This is an example of a common situation where code must guard against a
sequence of error conditions.  The code reads well if the
successful flow of control runs down the page, eliminating error cases
as they arise.  Since error cases tend to end in <code>return</code>
statements, the resulting code needs no <code>else</code> statements.
</p>
</div>

<p>
下例是一种常见的情况，代码必须防范一系列的错误条件。若控制流成功继续，
则说明程序已排除错误。由于出错时将以<code>return</code> 结束，
之后的代码也就无需 <code>else</code> 了。
</p>

<pre>
f, err := os.Open(name)
if err != nil {
	return err
}
d, err := f.Stat()
if err != nil {
	f.Close()
	return err
}
codeUsing(f, d)
</pre>


<div class="english">
<h3 id="redeclaration">Redeclaration and reassignment</h3>
</div>

<h3 id="重新声明">重新声明与再次赋值</h3>

<div class="english">
<p>
An aside: The last example in the previous section demonstrates a detail of how the
<code>:=</code> short declaration form works.
The declaration that calls <code>os.Open</code> reads,
</p>
</div>

<p>
题外话：上一节中最后一个示例展示了短声明 <code>:=</code> 如何使用。
调用了 <code>os.Open</code> 的声明为
</p>

<pre>
f, err := os.Open(name)
</pre>

<div class="english">
<p>
This statement declares two variables, <code>f</code> and <code>err</code>.
A few lines later, the call to <code>f.Stat</code> reads,
</p>
</div>

<p>
该语句声明了两个变量 <code>f</code> 和 <code>err</code>。在几行之后，又通过
</p>

<pre>
d, err := f.Stat()
</pre>

<div class="english">
<p>
which looks as if it declares <code>d</code> and <code>err</code>.
Notice, though, that <code>err</code> appears in both statements.
This duplication is legal: <code>err</code> is declared by the first statement,
but only <em>re-assigned</em> in the second.
This means that the call to <code>f.Stat</code> uses the existing
<code>err</code> variable declared above, and just gives it a new value.
</p>
</div>

<p>
调用了 <code>f.Stat</code>。它看起来似乎是声明了 <code>d</code> 和 <code>err</code>。
注意，尽管两个语句中都出现了 <code>err</code>，但这种重复仍然是合法的：<code>err</code>
在第一条语句中被声明，但在第二条语句中只是被<b>再次赋值</b>罢了。也就是说，调用
<code>f.Stat</code> 使用的是前面已经声明的 <code>err</code>，它只是被重新赋值了而已。
</p>

<div class="english">
<p>
In a <code>:=</code> declaration a variable <code>v</code> may appear even
if it has already been declared, provided:
</p>
</div>

<p>
在满足下列条件时，已被声明的变量 <code>v</code> 可出现在<code>:=</code> 声明中：
</p>

<div class="english">
<ul>
<li>this declaration is in the same scope as the existing declaration of <code>v</code>
(if <code>v</code> is already declared in an outer scope, the declaration will create a new variable §),</li>
<li>the corresponding value in the initialization is assignable to <code>v</code>, and</li>
<li>there is at least one other variable in the declaration that is being declared anew.</li>
</ul>
</div>

<ul>
<li>本次声明与已声明的 <code>v</code> 处于同一作用域中（若 <code>v</code>
已在外层作用域中声明过，则此次声明会创建一个新的变量§），</li>
<li>在初始化中与其类型相应的值才能赋予 <code>v</code>，且</li>
<li>在此次声明中至少另有一个变量是新声明的。</li>
</ul>

<div class="english">
<p>
This unusual property is pure pragmatism,
making it easy to use a single <code>err</code> value, for example,
in a long <code>if-else</code> chain.
You'll see it used often.
</p>
</div>

<p>
这个特性简直就是纯粹的实用主义体现，它使得我们可以很方面地只使用一个
<code>err</code> 值，例如，在一个相当长的 <code>if-else</code> 语句链中，
你会发现它用得很频繁。
</p>

<div class="english">
<p>
§ It's worth noting here that in Go the scope of function parameters and return values
is the same as the function body, even though they appear lexically outside the braces
that enclose the body.
</p>
</div>

<p>
§值得一提的是，即便Go中的函数形参和返回值在词法上处于大括号之外，
但它们的作用域和该函数体仍然相同。
</p>

<h3 id="for">For</h3>

<div class="english">
<p>
The Go <code>for</code> loop is similar to&mdash;but not the same as&mdash;C's.
It unifies <code>for</code>
and <code>while</code> and there is no <code>do-while</code>.
There are three forms, only one of which has semicolons.
</p>
</div>

<p>
Go的 <code>for</code> 循环类似于C，但却不尽相同。它统一了 <code>for</code> 和
<code>while</code>，不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号。
</p>

<div class="english">
<pre>
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</pre>
</div>

<pre>
// 如同C的for循环
for init; condition; post { }

// 如同C的while循环
for condition { }

// 如同C的for(;;)循环
for { }
</pre>

<div class="english">
<p>
Short declarations make it easy to declare the index variable right in the loop.
</p>
</div>

<p>
简短声明能让我们更容易在循环中声明下标变量：
</p>

<pre>
sum := 0
for i := 0; i &lt; 10; i++ {
	sum += i
}
</pre>

<div class="english">
<p>
If you're looping over an array, slice, string, or map,
or reading from a channel, a <code>range</code> clause can
manage the loop.
</p>
</div>

<p>
若你想遍历数组、切片、字符串或者映射，或从信道中读取消息，
<code>range</code> 子句能够帮你轻松实现循环。
</p>

<pre>
for key, value := range oldMap {
	newMap[key] = value
}
</pre>

<div class="english">
<p>
If you only need the first item in the range (the key or index), drop the second:
</p>
</div>

<p>
若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了：
</p>

<pre>
for key := range m {
	if key.expired() {
		delete(m, key)
	}
}
</pre>

<div class="english">
<p>
If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:
</p>
</div>

<p>
若你只需要该遍历中的第二个项（值），请使用<b>空白标识符</b>，即下划线来丢弃第一个值：
</p>

<pre>
sum := 0
for _, value := range array {
	sum += value
}
</pre>

<div class="english">
<p>
The blank identifier has many uses, as described in <a href="#blank">a later section</a>.
</p>
</div>

<p>
空白标识符还有多种用法，它会在<a href="#空白">后面的小节</a>中描述。
</p>

<div class="english">
<p>
For strings, the <code>range</code> does more work for you, breaking out individual
Unicode code points by parsing the UTF-8.
Erroneous encodings consume one byte and produce the
replacement rune U+FFFD.
(The name (with associated builtin type) <code>rune</code> is Go terminology for a
single Unicode code point.
See <a href="http://golang.org/ref/spec#Rune_literals">the language specification</a>
for details.)
The loop
</p>
</div>

<p>
对于字符串，<code>range</code> 能够提供更多便利。它能通过解析UTF-8，
将每个独立的Unicode码点分离出来。错误的编码将占用一个字节，并以符文U+FFFD来代替。
（名称“符文”和内建类型 <code>rune</code> 是Go对单个Unicode码点的成称谓。
详情见<a href="http://golang.org/ref/spec#符文字面">语言规范</a>）。循环
</p>

<div class="english">
<pre>
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
	fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
</pre>
<p>
prints
</p>
<pre>
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
</pre>
</div>

<pre>
for pos, char := range "日本\x80語" { // \x80 是个非法的UTF-8编码
	fmt.Printf("字符 %#U 始于字节位置 %d\n", char, pos)
}
</pre>
<p>
将打印
</p>
<pre>
字符 U+65E5 '日' 始于字节位置 0
字符 U+672C '本' 始于字节位置 3
字符 U+FFFD '�' 始于字节位置 6
字符 U+8A9E '語' 始于字节位置 7
</pre>

<div class="english">
<p>
Finally, Go has no comma operator and <code>++</code> and <code>--</code>
are statements not expressions.
Thus if you want to run multiple variables in a <code>for</code>
you should use parallel assignment (although that precludes <code>++</code> and <code>--</code>).
</div>

<p>
最后，Go没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。
因此，若你想要在 <code>for</code> 中使用多个变量，应采用平行赋值的方式
（因为它会拒绝 <code>++</code> 和 <code>--</code>）.
</p>

<div class="english">
<pre>
// Reverse a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
	a[i], a[j] = a[j], a[i]
}
</pre>
</div>

<pre>
// 反转 a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
	a[i], a[j] = a[j], a[i]
}
</pre>

<h3 id="switch">Switch</h3>

<div class="english">
<p>
Go's <code>switch</code> is more general than C's.
The expressions need not be constants or even integers,
the cases are evaluated top to bottom until a match is found,
and if the <code>switch</code> has no expression it switches on
<code>true</code>.
It's therefore possible&mdash;and idiomatic&mdash;to write an
<code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>
chain as a <code>switch</code>.
</p>
</div>

<p>
Go的 <code>switch</code> 比C的更通用。其表达式无需为常量或整数，<code>case</code>
语句会自上而下逐一进行求值直到匹配为止。若 <code>switch</code> 后面没有表达式，它将匹配
<code>true</code>，因此，我们可以将 <code>if-else-if-else</code> 链写成一个
<code>switch</code>，这也更符合Go的风格。
</p>

<pre>
func unhex(c byte) byte {
	switch {
	case '0' &lt;= c &amp;&amp; c &lt;= '9':
		return c - '0'
	case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
		return c - 'a' + 10
	case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
		return c - 'A' + 10
	}
	return 0
}
</pre>

<div class="english">
<p>
There is no automatic fall through, but cases can be presented
in comma-separated lists.
</p>
</div>

<p>
<code>switch</code> 并不会自动下溯，但 <code>case</code>
可通过逗号分隔来列举相同的处理条件。
</p>
<pre>
func shouldEscape(c byte) bool {
	switch c {
	case ' ', '?', '&amp;', '=', '#', '+', '%':
		return true
	}
	return false
}
</pre>

<div class="english">
<p>
Although they are not nearly as common in Go as some other C-like
languages, <code>break</code> statements can be used to terminate
a <code>switch</code> early.
Sometimes, though, it's necessary to break out of a surrounding loop,
not the switch, and in Go that can be accomplished by putting a label
on the loop and "breaking" to that label.
This example shows both uses.
</p>
</div>

<p>
尽管它们在Go中的用法和其它类C语言差不多，但 <code>break</code>
语句可以使 <code>switch</code> 提前终止。不仅是 <code>switch</code>，
有时候也必须打破层层的循环。在Go中，我们只需将标签放置到循环外，然后
“蹦”到那里即可。下面的例子展示了二者的用法。
</p>

<pre>
Loop:
	for n := 0; n &lt; len(src); n += size {
		switch {
		case src[n] &lt; sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] &lt; sizeTwo:
			if n+1 &gt;= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]&lt;&lt;shift)
		}
	}
</pre>

<div class="english">
<p>
Of course, the <code>continue</code> statement also accepts an optional label
but it applies only to loops.
</p>
</div>

<p>
当然，<code>continue</code> 语句也能接受一个可选的标签，不过它只能在循环中使用。
</p>

<div class="english">
<p>
To close this section, here's a comparison routine for byte slices that uses two
<code>switch</code> statements:
</p>
<pre>
// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
	for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
		switch {
		case a[i] &gt; b[i]:
			return 1
		case a[i] &lt; b[i]:
			return -1
		}
	}
	switch {
	case len(a) &gt; len(b):
		return 1
	case len(a) &lt; len(b):
		return -1
	}
	return 0
}
</pre>
</div>

<p>
作为这一节的结束，此程序通过使用两个 <code>switch</code> 语句对字节数组进行比较：
</p>
<pre>
// Compare 按字典顺序比较两个字节切片并返回一个整数。
// 若 a == b，则结果为零；若 a &lt; b；则结果为 -1；若 a &gt; b，则结果为 +1。
func Compare(a, b []byte) int {
	for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
		switch {
		case a[i] &gt; b[i]:
			return 1
		case a[i] &lt; b[i]:
			return -1
		}
	}
	switch {
	case len(a) &gt; len(b):
		return 1
	case len(a) &lt; len(b):
		return -1
	}
	return 0
}
</pre>

<div class="english">
<h2 id="type_switch">Type switch</h2>
</div>

<h2 id="类型选择">类型选择</h2>

<div class="english">
<p>
A switch can also be used to discover the dynamic type of an interface
variable.  Such a <em>type switch</em> uses the syntax of a type
assertion with the keyword <code>type</code> inside the parentheses.
If the switch declares a variable in the expression, the variable will
have the corresponding type in each clause.
It's also idiomatic to reuse the name in such cases, in effect declaring
a new variable with the same name but a different type in each case.
</p>
<pre>
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
	fmt.Printf("unexpected type %T", t)       // %T prints whatever type t has
case bool:
	fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
	fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
	fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
	fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
</pre>
</div>

<p>
<code>switch</code> 也可用于判断接口变量的动态类型。如 <b>类型选择</b>
通过圆括号中的关键字 <code>type</code> 使用类型断言语法。若 <code>switch</code>
在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。
</p>
<pre>
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
	fmt.Printf("unexpected type %T", t)       // %T 输出 t 是什么类型
case bool:
	fmt.Printf("boolean %t\n", t)             // t 是 bool 类型
case int:
	fmt.Printf("integer %d\n", t)             // t 是 int 类型
case *bool:
	fmt.Printf("pointer to boolean %t\n", *t) // t 是 *bool 类型
case *int:
	fmt.Printf("pointer to integer %d\n", *t) // t 是 *int 类型
}
</pre>

<div class="english">
<h2 id="functions">Functions</h2>
</div>

<h2 id="函数">函数</h2>

<div class="english">
<h3 id="multiple-returns">Multiple return values</h3>
</div>

<h3 id="多值返回">多值返回</h3>

<div class="english">
<p>
One of Go's unusual features is that functions and methods
can return multiple values.  This form can be used to
improve on a couple of clumsy idioms in C programs: in-band
error returns such as <code>-1</code> for <code>EOF</code>
and modifying an argument passed by address.
</p>
</div>

<p>
Go与众不同的特性之一就是函数和方法可返回多个值。这种形式可以改善C中一些笨拙的习惯：
将错误值返回（例如用 <code>-1</code> 表示 <code>EOF</code>）和修改通过地址传入的实参。
</p>

<div class="english">
<p>
In C, a write error is signaled by a negative count with the
error code secreted away in a volatile location.
In Go, <code>Write</code>
can return a count <i>and</i> an error: &ldquo;Yes, you wrote some
bytes but not all of them because you filled the device&rdquo;.
The signature of the <code>Write</code> method on files from
package <code>os</code> is:
</p>
</div>

<p>
在C中，写入操作发生的错误会用一个负数标记，而错误码会隐藏在某个不确定的位置。
而在Go中，<code>Write</code> 会返回写入的字节数<b>以及</b>一个错误：
“是的，您写入了一些字节，但并未全部写入，因为设备已满”。
在 <code>os</code> 包中，<code>File.Write</code> 的签名为：
</p>

<pre>
func (file *File) Write(b []byte) (n int, err error)
</pre>

<div class="english">
<p>
and as the documentation says, it returns the number of bytes
written and a non-nil <code>error</code> when <code>n</code>
<code>!=</code> <code>len(b)</code>.
This is a common style; see the section on error handling for more examples.
</p>
</div>

<p>
正如文档所述，它返回写入的字节数，并在<code>n != len(b)</code> 时返回一个非
<code>nil</code> 的 <code>error</code> 错误值。
这是一种常见的编码风格，更多示例见错误处理一节。
</p>

<div class="english">
<p>
A similar approach obviates the need to pass a pointer to a return
value to simulate a reference parameter.
Here's a simple-minded function to
grab a number from a position in a byte slice, returning the number
and the next position.
</p>
</div>

<p>
我们可以采用一种简单的方法。来避免为模拟引用参数而传入指针。
以下简单的函数可从字节数组中的特定位置获取其值，并返回该数值和下一个位置。
</p>

<pre>
func nextInt(b []byte, i int) (int, int) {
	for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
	}
	x := 0
	for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
		x = x*10 + int(b[i]) - '0'
	}
	return x, i
}
</pre>

<div class="english">
<p>
You could use it to scan the numbers in an input slice <code>b</code> like this:
</p>
</div>

<p>
你可以像下面这样，通过它扫描输入的切片 <code>b</code> 来获取数字。
</p>

<pre>
	for i := 0; i &lt; len(b); {
		x, i = nextInt(b, i)
		fmt.Println(x)
	}
</pre>

<div class="english">
<h3 id="named-results">Named result parameters</h3>
</div>

<h3 id="可命名结果">可命名结果形参</h3>

<div class="english">
<p>
The return or result "parameters" of a Go function can be given names and
used as regular variables, just like the incoming parameters.
When named, they are initialized to the zero values for their types when
the function begins; if the function executes a <code>return</code> statement
with no arguments, the current values of the result parameters are
used as the returned values.
</p>
</div>

<p>
Go函数的返回值或结果“形参”可被命名，并作为常规变量使用，就像传入的形参一样。
命名后，一旦该函数开始执行，它们就会被初始化为与其类型相应的零值；
若该函数执行了一条不带实参的 <code>return</code> 语句，则结果形参的当前值将被返回。
</p>

<div class="english">
<p>
The names are not mandatory but they can make code shorter and clearer:
they're documentation.
If we name the results of <code>nextInt</code> it becomes
obvious which returned <code>int</code>
is which.
</p>
</div>

<p>
此名称不是强制性的，但它们能使代码更加简短清晰：它们就是文档。若我们命名了
<code>nextInt</code> 的结果，那么它返回的 <code>int</code> 就值如其意了。
</p>

<pre>
func nextInt(b []byte, pos int) (value, nextPos int) {
</pre>

<div class="english">
<p>
Because named results are initialized and tied to an unadorned return, they can simplify
as well as clarify.  Here's a version
of <code>io.ReadFull</code> that uses them well:
</p>
</div>

<p>
由于被命名的结果已经初始化，且已经关联至无参数的返回，它们就能让代码简单而清晰。
下面的 <code>io.ReadFull</code> 就是个很好的例子：
</p>

<pre>
func ReadFull(r Reader, buf []byte) (n int, err error) {
	for len(buf) &gt; 0 &amp;&amp; err == nil {
		var nr int
		nr, err = r.Read(buf)
		n += nr
		buf = buf[nr:]
	}
	return
}
</pre>

<h3 id="defer">Defer</h3>

<div class="english">
<p>
Go's <code>defer</code> statement schedules a function call (the
<i>deferred</i> function) to be run immediately before the function
executing the <code>defer</code> returns.  It's an unusual but
effective way to deal with situations such as resources that must be
released regardless of which path a function takes to return.  The
canonical examples are unlocking a mutex or closing a file.
</p>
</div>

<p>
Go的 <code>defer</code> 语句用于预设一个函数调用（即<b>推迟执行</b>函数），
该函数会在执行 <code>defer</code> 的函数返回之前立即执行。它显得非比寻常，
但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。
典型的例子就是解锁互斥和关闭文件。
</p>

<div class="english">
<pre>
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer f.Close()  // f.Close will run when we're finished.

	var result []byte
	buf := make([]byte, 100)
	for {
		n, err := f.Read(buf[0:])
		result = append(result, buf[0:n]...) // append is discussed later.
		if err != nil {
			if err == io.EOF {
				break
			}
			return "", err  // f will be closed if we return here.
		}
	}
	return string(result), nil // f will be closed if we return here.
}
</pre>
</div>

<pre>
// Contents 将文件的内容作为字符串返回。
func Contents(filename string) (string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer f.Close()  // f.Close 会在我们结束后运行。

	var result []byte
	buf := make([]byte, 100)
	for {
		n, err := f.Read(buf[0:])
		result = append(result, buf[0:n]...) // append 将在后面讨论。
		if err != nil {
			if err == io.EOF {
				break
			}
			return "", err  // 我们在这里返回后，f 就会被关闭。
		}
	}
	return string(result), nil // 我们在这里返回后，f 就会被关闭。
}
</pre>

<div class="english">
<p>
Deferring a call to a function such as <code>Close</code> has two advantages.  First, it
guarantees that you will never forget to close the file, a mistake
that's easy to make if you later edit the function to add a new return
path.  Second, it means that the close sits near the open,
which is much clearer than placing it at the end of the function.
</p>
</div>

<p>
推迟诸如 <code>Close</code> 之类的函数调用有两点好处：第一，
它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时，
这种情况往往就会发生。第二，它意味着“关闭”离“打开”很近，
这总比将它放在函数结尾处要清晰明了。
</p>

<div class="english">
<p>
The arguments to the deferred function (which include the receiver if
the function is a method) are evaluated when the <i>defer</i>
executes, not when the <i>call</i> executes.  Besides avoiding worries
about variables changing values as the function executes, this means
that a single deferred call site can defer multiple function
executions.  Here's a silly example.
</p>
</div>

<p>
被推迟函数的实参（如果该函数为方法则还包括接收者）在<b>推迟</b>执行时就会求值，
而不是在<b>调用</b>执行时才求值。这样不仅无需担心变量值在函数执行时被改变，
同时还意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子。
</p>

<pre>
for i := 0; i &lt; 5; i++ {
	defer fmt.Printf("%d ", i)
}
</pre>

<div class="english">
<p>
Deferred functions are executed in LIFO order, so this code will cause
<code>4 3 2 1 0</code> to be printed when the function returns.  A
more plausible example is a simple way to trace function execution
through the program.  We could write a couple of simple tracing
routines like this:
</p>
</div>

<p>
被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印
<code>4 3 2 1 0</code>。一个更具实际意义的例子是通过一种简单的方法，
用程序来跟踪函数的执行。我们可以编写一对简单的跟踪例程：
</p>

<div class="english">
<pre>
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
	trace("a")
	defer untrace("a")
	// do something....
}
</pre>
</div>

<pre>
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// 像这样使用它们：
func a() {
	trace("a")
	defer untrace("a")
	// 做一些事情....
}
</pre>

<div class="english">
<p>
We can do better by exploiting the fact that arguments to deferred
functions are evaluated when the <code>defer</code> executes.  The
tracing routine can set up the argument to the untracing routine.
This example:
</p>
</div>

<p>
我们可以充分利用这个特点，即被推迟函数的实参在 <code>defer</code> 执行时才会被求值。
跟踪例程可针对反跟踪例程设置实参。以下例子：
</p>

<pre>
func trace(s string) string {
	fmt.Println("entering:", s)
	return s
}

func un(s string) {
	fmt.Println("leaving:", s)
}

func a() {
	defer un(trace("a"))
	fmt.Println("in a")
}

func b() {
	defer un(trace("b"))
	fmt.Println("in b")
	a()
}

func main() {
	b()
}
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
会打印
</p>

<pre>
entering: b
in b
entering: a
in a
leaving: a
leaving: b
</pre>

<div class="english">
<p>
For programmers accustomed to block-level resource management from
other languages, <code>defer</code> may seem peculiar, but its most
interesting and powerful applications come precisely from the fact
that it's not block-based but function-based.  In the section on
<code>panic</code> and <code>recover</code> we'll see another
example of its possibilities.
</p>
</div>

<p>
对于习惯其它语言中块级资源管理的程序员，<code>defer</code> 似乎有点怪异，
但它最有趣而强大的应用恰恰来自于其基于函数而非块的特点。在 <code>panic</code>
和 <code>recover</code> 这两节中，我们将看到关于它可能性的其它例子。
</p>

<div class="english">
<h2 id="data">Data</h2>
</div>

<h2 id="数据">数据</h2>

<div class="english">
<h3 id="allocation_new">Allocation with <code>new</code></h3>
</div>

<h3 id="new分配"><code>new</code> 分配</h3>

<div class="english">
<p>
Go has two allocation primitives, the built-in functions
<code>new</code> and <code>make</code>.
They do different things and apply to different types, which can be confusing,
but the rules are simple.
Let's talk about <code>new</code> first.
It's a built-in function that allocates memory, but unlike its namesakes
in some other languages it does not <em>initialize</em> the memory,
it only <em>zeros</em> it.
That is,
<code>new(T)</code> allocates zeroed storage for a new item of type
<code>T</code> and returns its address, a value of type <code>*T</code>.
In Go terminology, it returns a pointer to a newly allocated zero value of type
<code>T</code>.
</p>
</div>

<p>
Go提供了两种分配原语，即内建函数 <code>new</code> 和 <code>make</code>。
它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。
让我们先来看看 <code>new</code>。这是个用来分配内存的内建函数，
但与其它语言中的同名函数不同，它不会<b>初始化</b>内存，只会将内存<b>置零</b>。
也就是说，<code>new(T)</code> 会为类型为 <code>T</code> 的新项分配已置零的内存空间，
并返回它的地址，也就是一个类型为 <code>*T</code> 的值。用Go的术语来说，它返回一个指针，
该指针指向新分配的，类型为 <code>T</code> 的零值。
</p>

<div class="english">
<p>
Since the memory returned by <code>new</code> is zeroed, it's helpful to arrange
when designing your data structures that the
zero value of each type can be used without further initialization.  This means a user of
the data structure can create one with <code>new</code> and get right to
work.
For example, the documentation for <code>bytes.Buffer</code> states that
"the zero value for <code>Buffer</code> is an empty buffer ready to use."
Similarly, <code>sync.Mutex</code> does not
have an explicit constructor or <code>Init</code> method.
Instead, the zero value for a <code>sync.Mutex</code>
is defined to be an unlocked mutex.
</p>
</div>

<p>
既然 <code>new</code> 返回的内存已置零，那么当你设计数据结构时，
每种类型的零值就不必进一步初始化了，这意味着该数据结构的使用者只需用
<code>new</code> 创建一个新的对象就能正常工作。例如，<code>bytes.Buffer</code>
的文档中提到“零值的 <code>Buffer</code> 就是已准备就绪的缓冲区。"
同样，<code>sync.Mutex</code> 并没有显式的构造函数或 <code>Init</code> 方法，
而是零值的 <code>sync.Mutex</code> 就已经被定义为已解锁的互斥锁了。
</p>

<div class="english">
<p>
The zero-value-is-useful property works transitively. Consider this type declaration.
</p>
</div>

<p>
“零值属性”可以带来各种好处。考虑以下类型声明。
</p>

<pre>
type SyncedBuffer struct {
	lock    sync.Mutex
	buffer  bytes.Buffer
}
</pre>

<div class="english">
<p>
Values of type <code>SyncedBuffer</code> are also ready to use immediately upon allocation
or just declaration.  In the next snippet, both <code>p</code> and <code>v</code> will work
correctly without further arrangement.
</p>
</div>

<p>
<code>SyncedBuffer</code> 类型的值也是在声明时就分配好内存就绪了。后续代码中，
<code>p</code> 和 <code>v</code> 无需进一步处理即可正确工作。
</p>

<pre>
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
</pre>

<div class="english">
<h3 id="composite_literals">Constructors and composite literals</h3>
</div>

<h3 id="复合字面">构造函数与复合字面</h3>

<div class="english">
<p>
Sometimes the zero value isn't good enough and an initializing
constructor is necessary, as in this example derived from
package <code>os</code>.
</p>
</div>


<p>
有时零值还不够好，这时就需要一个初始化构造函数，如来自 <code>os</code> 包中的这段代码所示。
</p>

<pre>
func NewFile(fd int, name string) *File {
	if fd &lt; 0 {
		return nil
	}
	f := new(File)
	f.fd = fd
	f.name = name
	f.dirinfo = nil
	f.nepipe = 0
	return f
}
</pre>

<div class="english">
<p>
There's a lot of boiler plate in there.  We can simplify it
using a <i>composite literal</i>, which is
an expression that creates a
new instance each time it is evaluated.
</p>
</div>

<p>
这里显得代码过于冗长。我们可通过<b>复合字面</b>来简化它，
该表达式在每次求值时都会创建新的实例。
</p>

<pre>
func NewFile(fd int, name string) *File {
	if fd &lt; 0 {
		return nil
	}
	f := File{fd, name, nil, 0}
	return &amp;f
}
</pre>

<div class="english">
<p>
Note that, unlike in C, it's perfectly OK to return the address of a local variable;
the storage associated with the variable survives after the function
returns.
In fact, taking the address of a composite literal
allocates a fresh instance each time it is evaluated,
so we can combine these last two lines.
</p>
</div>

<p>
请注意，返回一个局部变量的地址完全没有问题，这点与C不同。该局部变量对应的数据
在函数返回后依然有效。实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存，
因此我们可以将上面的最后两行代码合并：
</p>

<pre>
	return &amp;File{fd, name, nil, 0}
</pre>

<div class="english">
<p>
The fields of a composite literal are laid out in order and must all be present.
However, by labeling the elements explicitly as <i>field</i><code>:</code><i>value</i>
pairs, the initializers can appear in any
order, with the missing ones left as their respective zero values.  Thus we could say
</p>
</div>

<p>
复合字面的字段必须按顺序全部列出。但如果以 <b>字段</b><code>:</code><b>值</b>
对的形式明确地标出元素，初始化字段时就可以按任何顺序出现，未给出的字段值将赋予零值。
因此，我们可以用如下形式：
</p>

<pre>
	return &amp;File{fd: fd, name: name}
</pre>

<div class="english">
<p>
As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type.  The expressions <code>new(File)</code> and <code>&amp;File{}</code> are equivalent.
</p>
</div>

<p>
少数情况下，若复合字面不包括任何字段，它将创建该类型的零值。表达式
<code>new(File)</code> 和 <code>&amp;File{}</code> 是等价的。
</p>

<div class="english">
<p>
Composite literals can also be created for arrays, slices, and maps,
with the field labels being indices or map keys as appropriate.
In these examples, the initializations work regardless of the values of <code>Enone</code>,
<code>Eio</code>, and <code>Einval</code>, as long as they are distinct.
</p>
</div>

<p>
复合字面同样可用于创建数组、切片以及映射，字段标签是索引还是映射键则视情况而定。
在下例初始化过程中，无论 <code>Enone</code>、<code>Eio</code> 和
<code>Einval</code> 的值是什么，只要它们的标签不同就行。
</p>

<pre>
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
</pre>

<div class="english">
<h3 id="allocation_make">Allocation with <code>make</code></h3>
</div>

<h3 id="make分配"><code>make</code> 分配</h3>

<div class="english">
<p>
Back to allocation.
The built-in function <code>make(T, </code><i>args</i><code>)</code> serves
a purpose different from <code>new(T)</code>.
It creates slices, maps, and channels only, and it returns an <em>initialized</em>
(not <em>zeroed</em>)
value of type <code>T</code> (not <code>*T</code>).
The reason for the distinction
is that these three types represent, under the covers, references to data structures that
must be initialized before use.
A slice, for example, is a three-item descriptor
containing a pointer to the data (inside an array), the length, and the
capacity, and until those items are initialized, the slice is <code>nil</code>.
For slices, maps, and channels,
<code>make</code> initializes the internal data structure and prepares
the value for use.
For instance,
</p>
</div>

<p>
再回到内存分配上来。内建函数 <code>make(T, <i></code>args<code></i>)</code>
的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为
<code>T</code>（而非 <code>*T</code>）的一个<b>已初始化</b> （而非<b>置零</b>）的值。
出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。
例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，
在这三项被初始化之前，该切片为 <code>nil</code>。对于切片、映射和信道，<code>make</code>
用于初始化其内部的数据结构并准备好将要使用的值。例如，
</p>

<pre>
make([]int, 10, 100)
</pre>

<div class="english">
<p>
allocates an array of 100 ints and then creates a slice
structure with length 10 and a capacity of 100 pointing at the first
10 elements of the array.
(When making a slice, the capacity can be omitted; see the section on slices
for more information.)
In contrast, <code>new([]int)</code> returns a pointer to a newly allocated, zeroed slice
structure, that is, a pointer to a <code>nil</code> slice value.
</p>
</div>

<p>
会分配一个具有100个 <code>int</code> 的数组空间，接着创建一个长度为10，
容量为100并指向该数组中前10个元素的切片结构。（生成切片时，其容量可以省略，更多信息见切片一节。）
与此相反，<code>new([]int)</code> 会返回一个指向新分配的，已置零的切片结构，
即一个指向 <code>nil</code> 切片值的指针。
</p>

<div class="english">
<p>
These examples illustrate the difference between <code>new</code> and
<code>make</code>.
</p>
</div>

<p>
下面的例子阐明了 <code>new</code> 和 <code>make</code> 之间的区别：
</p>

<div class="english">
<pre>
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
</pre>
</div>

<pre>
var p *[]int = new([]int)       // 分配切片结构；*p == nil；基本没用
var v  []int = make([]int, 100) // 切片 v 现在引用了一个具有 100 个 int 元素的新数组

// 没必要的复杂：
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 习惯用法：
v := make([]int, 100)
</pre>

<div class="english">
<p>
Remember that <code>make</code> applies only to maps, slices and channels
and does not return a pointer.
To obtain an explicit pointer allocate with <code>new</code> or take the address
of a variable explicitly.
</p>
</div>

<p>
请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。若要获得明确的指针，
请使用 <code>new</code> 分配内存。
</p>

<div class="english">
<h3 id="arrays">Arrays</h3>
</div>

<h3 id="数组">数组</h3>

<div class="english">
<p>
Arrays are useful when planning the detailed layout of memory and sometimes
can help avoid allocation, but primarily
they are a building block for slices, the subject of the next section.
To lay the foundation for that topic, here are a few words about arrays.
</p>
</div>

<p>
在详细规划内存布局时，数组是非常有用的，有时还能避免过多的内存分配，
但它们主要用作切片的构件。这是下一节的主题了，不过要先说上几句来为它做铺垫。
</p>

<div class="english">
<p>
There are major differences between the ways arrays work in Go and C.
In Go,
</p>
<ul>
<li>
Arrays are values. Assigning one array to another copies all the elements.
</li>
<li>
In particular, if you pass an array to a function, it
will receive a <i>copy</i> of the array, not a pointer to it.
<li>
The size of an array is part of its type.  The types <code>[10]int</code>
and <code>[20]int</code> are distinct.
</li>
</ul>
</div>

<p>
以下为数组在Go和C中的主要区别。在Go中，
</p>
<ul>
<li>
数组是值。将一个数组赋予另一个数组会复制其所有元素。
</li>
<li>
特别地，若将某个数组传入某个函数，它将接收到该数组的一份<b>副本</b>而非指针。
<li>
数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。
</li>
</ul>

<div class="english">
<p>
The value property can be useful but also expensive; if you want C-like behavior and efficiency,
you can pass a pointer to the array.
</p>
</div>

<p>
数组为值的属性很有用，但代价高昂；若你想要C那样的行为和效率，你可以传递一个指向该数组的指针。
</p>

<div class="english">
<pre>
func Sum(a *[3]float64) (sum float64) {
	for _, v := range *a {
		sum += v
	}
	return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Note the explicit address-of operator
</pre>
</div>

<pre>
func Sum(a *[3]float64) (sum float64) {
	for _, v := range *a {
		sum += v
	}
	return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // 注意显式的取址操作
</pre>

<div class="english">
<p>
But even this style isn't idiomatic Go.
Use slices instead.
</p>
</div>

<p>
但这并不是Go的习惯用法，切片才是。
</p>

<div class="english">
<h3 id="slices">Slices</h3>
</div>

<h3 id="切片">切片</h3>

<div class="english">
<p>
Slices wrap arrays to give a more general, powerful, and convenient
interface to sequences of data.  Except for items with explicit
dimension such as transformation matrices, most array programming in
Go is done with slices rather than simple arrays.
</p>
</div>

<p>
切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。
除了矩阵变换这类需要明确维度的情况外，Go中的大部分数组编程都是通过切片来完成的。
</p>

<div class="english">
<p>
Slices hold references to an underlying array, and if you assign one
slice to another, both refer to the same array.
If a function takes a slice argument, changes it makes to
the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array.  A <code>Read</code>
function can therefore accept a slice argument rather than a pointer
and a count; the length within the slice sets an upper
limit of how much data to read.  Here is the signature of the
<code>Read</code> method of the <code>File</code> type in package
<code>os</code>:
</p>
</div>

<p>
切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。
若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见，
这可以理解为传递了底层数组的指针。因此，<code>Read</code> 函数可接受一个切片实参
而非一个指针和一个计数；切片的长度决定了可读取数据的上限。以下为 <code>os</code>
包中 <code>File</code> 类型的 <code>Read</code> 方法签名:
</p>

<pre>
func (file *File) Read(buf []byte) (n int, err error)
</pre>

<div class="english">
<p>
The method returns the number of bytes read and an error value, if
any.  To read into the first 32 bytes of a larger buffer
<code>b</code>, <i>slice</i> (here used as a verb) the buffer.
</p>
</div>

<p>
该方法返回读取的字节数和一个错误值（若有的话）。若要从更大的缓冲区 <code>b</code>
中读取前32个字节，只需对其进行<b>切片</b>即可。
</p>

<pre>
	n, err := f.Read(buf[0:32])
</pre>

<div class="english">
<p>
Such slicing is common and efficient.  In fact, leaving efficiency aside for
the moment, the following snippet would also read the first 32 bytes of the buffer.
</p>
</div>

<p>
这种切片的方法常用且高效。若不谈效率，以下片段同样能读取该缓冲区的前32个字节。
</p>

<div class="english">
<pre>
	var n int
	var err error
	for i := 0; i &lt; 32; i++ {
		nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
		if nbytes == 0 || e != nil {
			err = e
			break
		}
		n += nbytes
	}
</pre>
</div>

<pre>
	var n int
	var err error
	for i := 0; i &lt; 32; i++ {
		nbytes, e := f.Read(buf[i:i+1])  // 读取一个字节
		if nbytes == 0 || e != nil {
			err = e
			break
		}
		n += nbytes
	}
</pre>

<div class="english">
<p>
The length of a slice may be changed as long as it still fits within
the limits of the underlying array; just assign it to a slice of
itself.  The <i>capacity</i> of a slice, accessible by the built-in
function <code>cap</code>, reports the maximum length the slice may
assume.  Here is a function to append data to a slice.  If the data
exceeds the capacity, the slice is reallocated.  The
resulting slice is returned.  The function uses the fact that
<code>len</code> and <code>cap</code> are legal when applied to the
<code>nil</code> slice, and return 0.
</p>
</div>

<p>
只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋予其自身的切片即可。
切片的<b>容量</b>可通过内建函数 <code>cap</code> 获得，它将给出该切片可取得的最大长度。
以下是将数据追加到切片的函数。若数据超出其容量，则会重新分配该切片。返回值即为所得的切片。
该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code>
切片时是合法的，它会返回0.
</p>

<div class="english">
<pre>
func Append(slice, data[]byte) []byte {
	l := len(slice)
	if l + len(data) &gt; cap(slice) {  // reallocate
		// Allocate double what's needed, for future growth.
		newSlice := make([]byte, (l+len(data))*2)
		// The copy function is predeclared and works for any slice type.
		copy(newSlice, slice)
		slice = newSlice
	}
	slice = slice[0:l+len(data)]
	for i, c := range data {
		slice[l+i] = c
	}
	return slice
}
</pre>
</div>

<pre>
func Append(slice, data[]byte) []byte {
	l := len(slice)
	if l + len(data) &gt; cap(slice) {  // 重新分配
		// 为了后面的增长，需分配两份。
		newSlice := make([]byte, (l+len(data))*2)
		// copy 函数是预声明的，且可用于任何切片类型。
		copy(newSlice, slice)
		slice = newSlice
	}
	slice = slice[0:l+len(data)]
	for i, c := range data {
		slice[l+i] = c
	}
	return slice
}
</pre>

<div class="english">
<p>
We must return the slice afterwards because, although <code>Append</code>
can modify the elements of <code>slice</code>, the slice itself (the run-time data
structure holding the pointer, length, and capacity) is passed by value.
</p>
</div>

<p>
最终我们必须返回切片，因为尽管 <code>Append</code> 可修改 <code>slice</code>
的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。
</p>

<div class="english">
<p>
The idea of appending to a slice is so useful it's captured by the
<code>append</code> built-in function.  To understand that function's
design, though, we need a little more information, so we'll return
to it later.
</p>
</div>

<p>

向切片追加东西的想法非常有用，因此有专门的内建函数 <code>append</code>。
要理解该函数的设计，我们还需要一些额外的信息，我们将稍后再介绍它。
</p>

<div class="english">
<h3 id="two_dimensional_slices">Two-dimensional slices</h3>
</div>

<h3 id="二维切片">二维切片</h3>

<div class="english">
<p>
Go's arrays and slices are one-dimensional.
To create the equivalent of a 2D array or slice, it is necessary to define an array-of-arrays
or slice-of-slices, like this:
</p>
</div>

<p>
Go的数组和切片都是一维的。要创建等价的二维数组或切片，就必须定义一个数组的数组，
或切片的切片，就像这样：
</p>

<div class="english">
<pre>
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
</pre>
</div>

<pre>
type Transform [3][3]float64  // 一个 3x3 的数组，其实是包含多个数组的一个数组。
type LinesOfText [][]byte     // 包含多个字节切片的一个切片。
</pre>

<div class="english">
<p>
Because slices are variable-length, it is possible to have each inner
slice be a different length.
That can be a common situation, as in our <code>LinesOfText</code>
example: each line has an independent length.
</p>
</div>

<p>
由于切片长度是可变的，因此其内部可能拥有多个不同长度的切片。在我们的
<code>LinesOfText</code> 例子中，这是种常见的情况：每行都有其自己的长度。
</p>

<pre>
text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
</pre>

<div class="english">
<p>
Sometimes it's necessary to allocate a 2D slice, a situation that can arise when
processing scan lines of pixels, for instance.
There are two ways to achieve this.
One is to allocate each slice independently; the other
is to allocate a single array and point the individual slices into it.
Which to use depends on your application.
If the slices might grow or shrink, they should be allocated independently
to avoid overwriting the next line; if not, it can be more efficient to construct
the object with a single allocation.
For reference, here are sketches of the two methods.
First, a line a time:
</p>
</div>

<p>
有时必须分配一个二维数组，例如在处理像素的扫描行时，这种情况就会发生。
我们有两种方式来达到这个目的。一种就是独立地分配每一个切片；而另一种就是只分配一个数组，
将各个切片都指向它。采用哪种方式取决于你的应用。若切片会增长或收缩，
就应该通过独立分配来避免覆盖下一行；若不会，用单次分配来构造对象会更加高效。
以下是这两种方法的大概代码，仅供参考。首先是一次一行的：
</p>

<div class="english">
<pre>
// Allocate the top-level slice.
picture := make([][]uint8, YSize) // One row per unit of y.
// Loop over the rows, allocating the slice for each row.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
</pre>
</div>

<pre>
// 分配顶层切片。
picture := make([][]uint8, YSize) // 每 y 个单元一行。
// 遍历行，为每一行都分配切片
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
</pre>

<div class="english">
<p>
And now as one allocation, sliced into lines:
</p>
</div>

<p>
现在是一次分配，对行进行切片：
</p>

<div class="english">
<pre>
// Allocate the top-level slice, the same as before.
picture := make([][]uint8, YSize) // One row per unit of y.
// Allocate one large slice to hold all the pixels.
pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
// Loop over the rows, slicing each row from the front of the remaining pixels slice.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
</pre>
</div>

<pre>
// 分配顶层切片，和前面一样。
picture := make([][]uint8, YSize) // 每 y 个单元一行。
// 分配一个大的切片来保存所有像素
pixels := make([]uint8, XSize*YSize) // 拥有类型 []uint8，尽管图片是 [][]uint8.
// 遍历行，从剩余像素切片的前面切出每行来。
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
</pre>

<div class="english">
<h3 id="maps">Maps</h3>
</div>

<h3 id="映射">映射</h3>

<div class="english">
<p>
Maps are a convenient and powerful built-in data structure that associate
values of one type (the <em>key</em>) with values of another type
(the <em>element</em> or <em>value</em>)
The key can be of any type for which the equality operator is defined,
such as integers,
floating point and complex numbers,
strings, pointers, interfaces (as long as the dynamic type
supports equality), structs and arrays.
Slices cannot be used as map keys,
because equality is not defined on them.
Like slices, maps hold references to an underlying data structure.
If you pass a map to a function
that changes the contents of the map, the changes will be visible
in the caller.
</p>
</div>

<p>
映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任何相等性操作符支持的类型，
如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。
切片不能用作映射键，因为它们的相等性还未定义。与切片一样，映射也是引用类型。
若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。
</p>

<div class="english">
<p>
Maps can be constructed using the usual composite literal syntax
with colon-separated key-value pairs,
so it's easy to build them during initialization.
</p>
</div>

<p>
映射可使用一般的复合字面语法进行构建，其键-值对使用逗号分隔，因此可在初始化时很容易地构建它们。
</p>

<pre>
var timeZone = map[string]int{
	"UTC":  0*60*60,
	"EST": -5*60*60,
	"CST": -6*60*60,
	"MST": -7*60*60,
	"PST": -8*60*60,
}
</pre>

<div class="english">
<p>
Assigning and fetching map values looks syntactically just like
doing the same for arrays and slices except that the index doesn't
need to be an integer.
</p>
</div>

<p>
赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。
</p>

<pre>
offset := timeZone["EST"]
</pre>

<div class="english">
<p>
An attempt to fetch a map value with a key that
is not present in the map will return the zero value for the type
of the entries
in the map.  For instance, if the map contains integers, looking
up a non-existent key will return <code>0</code>.
A set can be implemented as a map with value type <code>bool</code>.
Set the map entry to <code>true</code> to put the value in the set, and then
test it by simple indexing.
</p>
</div>

<p>
若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值。
例如，若某个映射包含整数，当查找一个不存在的键时会返回 <code>0</code>。
集合可实现成一个值类型为 <code>bool</code> 的映射。将该映射中的项置为
<code>true</code> 可将该值放入集合中，此后通过简单的索引操作即可判断是否存在。
</p>

<div class="english">
<pre>
attended := map[string]bool{
	"Ann": true,
	"Joe": true,
	...
}

if attended[person] { // will be false if person is not in the map
	fmt.Println(person, "was at the meeting")
}
</pre>
</div>

<pre>
attended := map[string]bool{
	"Ann": true,
	"Joe": true,
	...
}

if attended[person] { // 若某人不在此映射中，则为 false
	fmt.Println(person, "正在开会")
}
</pre>

<div class="english">
<p>
Sometimes you need to distinguish a missing entry from
a zero value.  Is there an entry for <code>"UTC"</code>
or is that the empty string because it's not in the map at all?
You can discriminate with a form of multiple assignment.
</p>
</div>


<p>
有时你需要区分某项是不存在还是其值为零值。如对于一个值本应为零的 <code>"UTC"</code>
条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。
</p>

<pre>
var seconds int
var ok bool
seconds, ok = timeZone[tz]
</pre>

<div class="english">
<p>
For obvious reasons this is called the &ldquo;comma ok&rdquo; idiom.
In this example, if <code>tz</code> is present, <code>seconds</code>
will be set appropriately and <code>ok</code> will be true; if not,
<code>seconds</code> will be set to zero and <code>ok</code> will
be false.
Here's a function that puts it together with a nice error report:
</p>
</div>

<p>
显然，我们可称之为“逗号 ok”惯用法。在下面的例子中，若 <code>tz</code> 存在，
<code>seconds</code> 就会被赋予适当的值，且 <code>ok</code> 会被置为 <code>true</code>；
若不存在，<code>seconds</code> 则会被置为零，而 <code>ok</code> 会被置为 <code>false</code>。
</p>

<pre>
func offset(tz string) int {
	if seconds, ok := timeZone[tz]; ok {
		return seconds
	}
	log.Println("unknown time zone:", tz)
	return 0
}
</pre>

<div class="english">
<p>
To test for presence in the map without worrying about the actual value,
you can use the <a href="#blank">blank identifier</a> (<code>_</code>)
in place of the usual variable for the value.
</p>
</div>

<p>
若仅需判断映射中是否存在某项而不关心实际的值，可使用<a href="#空白">空白标识符</a>
（<code>_</code>）来代替该值的一般变量。
</p>

<pre>
_, present := timeZone[tz]
</pre>

<div class="english">
<p>
To delete a map entry, use the <code>delete</code>
built-in function, whose arguments are the map and the key to be deleted.
It's safe to do this even if the key is already absent
from the map.
</p>
</div>

<p>
要删除映射中的某项，可使用内建函数 <code>delete</code>，它以映射及要被删除的键为实参。
即便对应的键不在该映射中，此操作也是安全的。
</p>

<div class="english">
<pre>
delete(timeZone, "PDT")  // Now on Standard Time
</pre>
</div>

<pre>
delete(timeZone, "PDT")  // 现在用标准时间
</pre>

<div class="english">
<h3 id="printing">Printing</h3>
</div>

<h3 id="打印">打印</h3>

<div class="english">
<p>
Formatted printing in Go uses a style similar to C's <code>printf</code>
family but is richer and more general. The functions live in the <code>fmt</code>
package and have capitalized names: <code>fmt.Printf</code>, <code>fmt.Fprintf</code>,
<code>fmt.Sprintf</code> and so on.  The string functions (<code>Sprintf</code> etc.)
return a string rather than filling in a provided buffer.
</p>
</div>

<p>
Go采用的格式化打印风格和C的 <code>printf</code> 族类似，但却更加丰富而通用。
这些函数位于 <code>fmt</code> 包中，且函数名首字母均为大写：如
<code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code> 等。
字符串函数（<code>Sprintf</code> 等）会返回一个字符串，而非填充给定的缓冲区。
</p>

<div class="english">
<p>
You don't need to provide a format string.  For each of <code>Printf</code>,
<code>Fprintf</code> and <code>Sprintf</code> there is another pair
of functions, for instance <code>Print</code> and <code>Println</code>.
These functions do not take a format string but instead generate a default
format for each argument. The <code>Println</code> versions also insert a blank
between arguments and append a newline to the output while
the <code>Print</code> versions add blanks only if the operand on neither side is a string.
In this example each line produces the same output.
</p>
</div>

<p>
你无需提供一个格式字符串。每个 <code>Printf</code>、<code>Fprintf</code> 和
<code>Sprintf</code> 都分别对应另外的函数，如 <code>Print</code> 与 <code>Println</code>。
这些函数并不接受格式字符串，而是为每个实参生成一种默认格式。<code>Println</code>
系列的函数还会在实参中插入空格，并在输出时追加一个换行符，而 <code>Print</code>
版本仅在操作数两侧都没有字符串时才添加空白。以下示例中各行产生的输出都是一样的。
</p>

<pre>
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
</pre>

<div class="english">
<p>
The formatted print functions <code>fmt.Fprint</code>
and friends take as a first argument any object
that implements the <code>io.Writer</code> interface; the variables <code>os.Stdout</code>
and <code>os.Stderr</code> are familiar instances.
</p>
</div>

<p>
<code>fmt.Fprint</code> 一类的格式化打印函数可接受任何实现了 <code>io.Writer</code>
接口的对象作为第一个实参；变量<code>os.Stdout</code> 与 <code>os.Stderr</code>
都是人们熟知的例子。
</p>

<div class="english">
<p>
Here things start to diverge from C.  First, the numeric formats such as <code>%d</code>
do not take flags for signedness or size; instead, the printing routines use the
type of the argument to decide these properties.
</p>
</div>

<p>
从这里开始，就与C有些不同了。首先，像 <code>%d</code> 这样的数值格式并不接受表示符号或大小的标记，
打印例程会根据实参的类型来决定这些属性。
</p>

<pre>
var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
18446744073709551615 ffffffffffffffff; -1 -1
</pre>

<div class="english">
<p>
If you just want the default conversion, such as decimal for integers, you can use
the catchall format <code>%v</code> (for &ldquo;value&rdquo;); the result is exactly
what <code>Print</code> and <code>Println</code> would produce.
Moreover, that format can print <em>any</em> value, even arrays, slices, structs, and
maps.  Here is a print statement for the time zone map defined in the previous section.
</p>
</div>

<p>
若你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式
<code>%v</code>（对应“值”）；其结果与 <code>Print</code> 和 <code>Println</code>
的输出完全相同。此外，这种格式还能打印<b>任意</b>值，甚至包括数组、结构体和映射。
以下是打印上一节中定义的时区映射的语句。
</p>

<div class="english">
<pre>
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
</pre>
<p>
which gives output
</p>
<pre>
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</pre>
</div>

<pre>
fmt.Printf("%v\n", timeZone)  // 或只用 fmt.Println(timeZone)
</pre>
<p>
这会输出
</p>
<pre>
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</pre>

<div class="english">
<p>
For maps the keys may be output in any order, of course.
When printing a struct, the modified format <code>%+v</code> annotates the
fields of the structure with their names, and for any value the alternate
format <code>%#v</code> prints the value in full Go syntax.
</p>
</div>

<p>
当然，映射中的键可能按任意顺序输出。当打印结构体时，改进的格式 <code>%+v</code>
会为结构体的每个字段添上字段名，而另一种格式 <code>%#v</code> 将完全按照Go的语法打印值。
</p>

<pre>
type T struct {
	a int
	b float64
	c string
}
t := &amp;T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
</pre>

<div class="english">
<p>
(Note the ampersands.)
That quoted string format is also available through <code>%q</code> when
applied to a value of type <code>string</code> or <code>[]byte</code>.
The alternate format <code>%#q</code> will use backquotes instead if possible.
(The <code>%q</code> format also applies to integers and runes, producing a
single-quoted rune constant.)
Also, <code>%x</code> works on strings, byte arrays and byte slices as well as
on integers, generating a long hexadecimal string, and with
a space in the format (<code>%&nbsp;x</code>) it puts spaces between the bytes.
</p>
</div>

<p>
（请注意其中的&amp;符号）当遇到 <code>string</code> 或 <code>[]byte</code> 值时，
可使用 <code>%q</code> 产生带引号的字符串；而格式 <code>%#q</code> 会尽可能使用反引号。
（<code>%q</code> 格式也可用于整数和符文，它会产生一个带单引号的符文常量。）
此外，<code>%x</code> 还可用于字符串、字节数组以及整数，并生成一个很长的十六进制字符串，
而带空格的格式（<code>%&nbsp;x</code>）还会在字节之间插入空格。
</p>

<div class="english">
<p>
Another handy format is <code>%T</code>, which prints the <em>type</em> of a value.
</p>
</div>

<p>
另一种实用的格式是 <code>%T</code>，它会打印某个值的<b>类型</b>.
</p>

<pre>
fmt.Printf(&quot;%T\n&quot;, timeZone)
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
会打印
</p>

<pre>
map[string] int
</pre>

<div class="english">
<p>
If you want to control the default format for a custom type, all that's required is to define
a method with the signature <code>String() string</code> on the type.
For our simple type <code>T</code>, that might look like this.
</p>
</div>

<p>
若你想控制自定义类型的默认格式，只需为该类型定义一个具有 <code>String() string</code>
签名的方法。对于我们简单的类型 <code>T</code>，可进行如下操作。
</p>

<pre>
func (t *T) String() string {
	return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
</pre>

<div class="english">
<p>
to print in the format
</p>
</div>

<p>
会打印出如下格式：
</p>

<pre>
7/-2.35/"abc\tdef"
</pre>

<div class="english">
<p>
(If you need to print <em>values</em> of type <code>T</code> as well as pointers to <code>T</code>,
the receiver for <code>String</code> must be of value type; this example used a pointer because
that's more efficient and idiomatic for struct types.
See the section below on <a href="#pointers_vs_values">pointers vs. value receivers</a> for more information.)
</p>
</div>

<p>
（如果你需要像指向 <code>T</code> 的指针那样打印类型 <code>T</code> 的<b>值</b>，
<code>String</code> 的接收者就必须是值类型的；上面的例子中接收者是一个指针，
因为这对结构来说更高效而通用。更多详情见<a href="#指针vs值">指针vs.值接收者</a>一节.）
</p>

<div class="english">
<p>
Our <code>String</code> method is able to call <code>Sprintf</code> because the
print routines are fully reentrant and can be wrapped this way.
There is one important detail to understand about this approach,
however: don't construct a <code>String</code> method by calling
<code>Sprintf</code> in a way that will recur into your <code>String</code>
method indefinitely.  This can happen if the <code>Sprintf</code>
call attempts to print the receiver directly as a string, which in
turn will invoke the method again.  It's a common and easy mistake
to make, as this example shows.
</p>
</div>

<p>
我们的 <code>String</code> 方法也可调用 <code>Sprintf</code>，
因为打印例程可以完全重入并按这种方式封装。不过要理解这种方式，还有一个重要的细节：
请勿通过调用 <code>Sprintf</code> 来构造 <code>String</code>
方法，因为它会无限递归你的的 <code>String</code> 方法。
</p>

<div class="english">
<pre>
type MyString string

func (m MyString) String() string {
	return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
</pre>
</div>

<pre>
type MyString string

func (m MyString) String() string {
	return fmt.Sprintf("MyString=%s", m) // 错误：会无限递归
}
</pre>

<div class="english">
<p>
It's also easy to fix: convert the argument to the basic string type, which does not have the
method.
</p>
</div>

<p>
要解决这个问题也很简单：将该实参转换为基本的字符串类型，它没有这个方法。
</p>

<div class="english">
<pre>
type MyString string
func (m MyString) String() string {
	return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
</pre>
</div>

<pre>
type MyString string
func (m MyString) String() string {
	return fmt.Sprintf("MyString=%s", string(m)) // 可以：注意转换
}
</pre>

<div class="english">
<p>
In the <a href="#initialization">initialization section</a> we'll see another technique that avoids this recursion.
</p>
</div>

<p>
在<a href="#初始化">初始化</a>一节中，我们将看到避免这种递归的另一种技术。
</p>

<div class="english">
<p>
Another printing technique is to pass a print routine's arguments directly to another such routine.
The signature of <code>Printf</code> uses the type <code>...interface{}</code>
for its final argument to specify that an arbitrary number of parameters (of arbitrary type)
can appear after the format.
</p>
</div>

<p>
另一种打印技术就是将打印例程的实参直接传入另一个这样的例程。<code>Printf</code>
的签名为其最后的实参使用了 <code>...interface{}</code>
类型，这样格式的后面就能出现任意数量，任意类型的形参了。
</p>

<pre>
func Printf(format string, v ...interface{}) (n int, err error) {
</pre>

<div class="english">
<p>
Within the function <code>Printf</code>, <code>v</code> acts like a variable of type
<code>[]interface{}</code> but if it is passed to another variadic function, it acts like
a regular list of arguments.
Here is the implementation of the
function <code>log.Println</code> we used above. It passes its arguments directly to
<code>fmt.Sprintln</code> for the actual formatting.
</p>
</div>

<p>
在 <code>Printf</code> 函数中，<code>v</code> 看起来更像是 <code>[]interface{}</code>
类型的变量，但如果将它传递到另一个变参函数中，它就像是常规实参列表了。
以下是我们之前用过的 <code>log.Println</code> 的实现。它直接将其实参传递给
<code>fmt.Sprintln</code> 进行实际的格式化。
</p>

<div class="english">
<pre>
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
	std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
</pre>
</div>

<pre>
// Println 通过 fmt.Println 的方式将日志打印到标准记录器。
func Println(v ...interface{}) {
	std.Output(2, fmt.Sprintln(v...))  // Output 接受形参 (int, string)
}
</pre>

<div class="english">
<p>
We write <code>...</code> after <code>v</code> in the nested call to <code>Sprintln</code> to tell the
compiler to treat <code>v</code> as a list of arguments; otherwise it would just pass
<code>v</code> as a single slice argument.
</p>
</div>

<p>
在该 <code>Sprintln</code> 嵌套调用中，我们将 <code>...</code> 写在 <code>v</code>
之后来告诉编译器将 <code>v</code> 视作一个实参列表，否则它会将 <code>v</code>
当做单一的切片实参来传递。
</p>

<div class="english">
<p>
There's even more to printing than we've covered here.  See the <code>godoc</code> documentation
for package <code>fmt</code> for the details.
</p>
</div>

<p>
还有很多关于打印知识点没有提及。详情请参阅 <code>godoc</code> 对 <code>fmt</code> 包的说明文档。
</p>

<div class="english">
<p>
By the way, a <code>...</code> parameter can be of a specific type, for instance <code>...int</code>
for a min function that chooses the least of a list of integers:
</p>
</div>

<p>
顺便一提，<code>...</code> 形参可指定具体的类型，例如从整数列表中选出最小值的函数
<code>min</code>，其形参可为 <code>...int</code> 类型。
</p>

<div class="english">
<pre>
func Min(a ...int) int {
	min := int(^uint(0) >> 1)  // largest int
	for _, i := range a {
		if i &lt; min {
			min = i
		}
	}
	return min
}
</pre>
</div>

<pre>
func Min(a ...int) int {
	min := int(^uint(0) >> 1)  // 最大的 int
	for _, i := range a {
		if i &lt; min {
			min = i
		}
	}
	return min
}
</pre>

<div class="english">
<h3 id="append">Append</h3>
</div>

<h3 id="追加">追加</h3>

<div class="english">
<p>
Now we have the missing piece we needed to explain the design of
the <code>append</code> built-in function.  The signature of <code>append</code>
is different from our custom <code>Append</code> function above.
Schematically, it's like this:
</p>
</div>

<p>
现在我们要对内建函数 <code>append</code> 的设计进行补充说明。<code>append</code>
函数的签名不同于前面我们自定义的 <code>Append</code> 函数。大致来说，它就像这样：
</p>

<div class="english">
<pre>
func append(slice []<i>T</i>, elements ...<i>T</i>) []<i>T</i>
</pre>
</div>

<pre>
func append(slice []<i>T</i>, 元素 ...<i>T</i>) []<i>T</i>
</pre>

<div class="english">
<p>
where <i>T</i> is a placeholder for any given type.  You can't
actually write a function in Go where the type <code>T</code>
is determined by the caller.
That's why <code>append</code> is built in: it needs support from the
compiler.
</p>
</div>

其中的 <i>T</i> 为任意给定类型的占位符。实际上，你无法在Go中编写一个类型
<code>T</code> 由调用者决定的函数。这也就是为何 <code>append</code>
为内建函数的原因：它需要编译器的支持。

<div class="english">
<p>
What <code>append</code> does is append the elements to the end of
the slice and return the result.  The result needs to be returned
because, as with our hand-written <code>Append</code>, the underlying
array may change.  This simple example
</p>
</div>

<p>
<code>append</code> 会在切片末尾追加元素并返回结果。我们必须返回结果，
原因与我们手写的 <code>Append</code> 一样，即底层数组可能会被改变。以下简单的例子
</p>

<pre>
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</pre>

<div class="english">
<p>
prints <code>[1 2 3 4 5 6]</code>.  So <code>append</code> works a
little like <code>Printf</code>, collecting an arbitrary number of
arguments.
</p>
</div>

<p>
将打印 <code>[1 2 3 4 5 6]</code>。因此 <code>append</code> 有点像 <code>Printf</code>
那样，可接受任意数量的实参。
</p>

<div class="english">
<p>
But what if we wanted to do what our <code>Append</code> does and
append a slice to a slice?  Easy: use <code>...</code> at the call
site, just as we did in the call to <code>Output</code> above.  This
snippet produces identical output to the one above.
</p>
</div>

<p>
但如果我们要像 <code>Append</code> 那样将一个切片追加到另一个切片中呢？
很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code>
那样。以下代码片段的输出与上一个相同。
</p>

<pre>
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
</pre>

<div class="english">
<p>
Without that <code>...</code>, it wouldn't compile because the types
would be wrong; <code>y</code> is not of type <code>int</code>.
</p>
</div>

<p>
如果没有 <code>...</code>，它就会由于类型错误而无法编译，因为 <code>y</code>
不是 <code>int</code> 类型的。
</p>

<div class="english">
<h2 id="initialization">Initialization</h2>
</div>

<h2 id="初始化">初始化</h2>

<div class="english">
<p>
Although it doesn't look superficially very different from
initialization in C or C++, initialization in Go is more powerful.
Complex structures can be built during initialization and the ordering
issues among initialized objects, even among different packages, are handled
correctly.
</p>
</div>

<p>
<p>
尽管从表面上看，Go的初始化过程与C或C++并不算太大，但它确实更为强大。
在初始化过程中，不仅可以构建复杂的结构，还能正确处理不同包对象间的初始化顺序。
</p>

<div class="english">
<h3 id="constants">Constants</h3>
</div>

<h3 id="常量">常量</h3>

<div class="english">
<p>
Constants in Go are just that&mdash;constant.
They are created at compile time, even when defined as
locals in functions,
and can only be numbers, characters (runes), strings or booleans.
Because of the compile-time restriction, the expressions
that define them must be constant expressions,
evaluatable by the compiler.  For instance,
<code>1&lt;&lt;3</code> is a constant expression, while
<code>math.Sin(math.Pi/4)</code> is not because
the function call to <code>math.Sin</code> needs
to happen at run time.
</p>
</div>

<p>
Go中的常量就是不变量。它们在编译时创建，即便它们可能是函数中定义的局部变量。
常量只能是数字、字符（符文）、字符串或布尔值。由于编译时的限制，
定义它们的表达式必须也是可被编译器求值的常量表达式。例如 <code>1&lt;&lt;3</code>
就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code>
则不是，因为对 <code>math.Sin</code> 的函数调用在运行时才会发生。
</p>

<div class="english">
<p>
In Go, enumerated constants are created using the <code>iota</code>
enumerator.  Since <code>iota</code> can be part of an expression and
expressions can be implicitly repeated, it is easy to build intricate
sets of values.
</p>
</div>

<p>
在Go中，枚举常量使用枚举器 <code>iota</code> 创建。由于 <code>iota</code>
可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合了。
</p>

{{code "/doc/progs/eff_bytesize.go" `/^type ByteSize/` `/^\)/`}}

<div class="english">
<p>
The ability to attach a method such as <code>String</code> to any
user-defined type makes it possible for arbitrary values to format themselves
automatically for printing.
Although you'll see it most often applied to structs, this technique is also useful for
scalar types such as floating-point types like <code>ByteSize</code>.
</p>
</div>

<p>
由于可将 <code>String</code> 之类的方法附加在用户定义的类型上，
因此它就为打印时自动格式化任意值提供了可能性，即便是作为一个通用类型的一部分。
尽管你常常会看到这种技术应用于结构体，但它对于像 <code>ByteSize</code>
之类的浮点数标量等类型也是有用的。
</p>

{{code "/doc/progs/eff_bytesize.go" `/^func.*ByteSize.*String/` `/^}/`}}

<div class="english">
<p>
The expression <code>YB</code> prints as <code>1.00YB</code>,
while <code>ByteSize(1e13)</code> prints as <code>9.09TB</code>.
</p>
</div>

<p>
表达式 <code>YB</code> 会打印出 <code>1.00YB</code>，而
<code>ByteSize(1e13)</code> 则会打印出 <code>9.09</code>。
</p>

<div class="english">
<p>
The use here of <code>Sprintf</code>
to implement <code>ByteSize</code>'s <code>String</code> method is safe
(avoids recurring indefinitely) not because of a conversion but
because it calls <code>Sprintf</code> with <code>%f</code>,
which is not a string format: <code>Sprintf</code> will only call
the <code>String</code> method when it wants a string, and <code>%f</code>
wants a floating-point value.
</p>
</div>

<p>
在这里用 <code>Sprintf</code> 实现 <code>ByteSize</code> 的 <code>String</code>
方法很安全（不会无限递归），这倒不是因为类型转换，而是它以 <code>%f</code>
调用了 <code>Sprintf</code>，它并不是一种字符串格式：<code>Sprintf</code>
只会在它需要字符串时才调用 <code>String</code> 方法，而 <code>%f</code>
需要一个浮点数值。
</p>

<div class="english">
<h3 id="variables">Variables</h3>
</div>

<h3 id="变量">变量</h3>

<div class="english">
<p>
Variables can be initialized just like constants but the
initializer can be a general expression computed at run time.
</p>
</div>

<p>
变量的初始化与常量类似，但其初始值也可以是在运行时才被计算的一般表达式。
</p>

<pre>
var (
	home   = os.Getenv("HOME")
	user   = os.Getenv("USER")
	gopath = os.Getenv("GOPATH")
)
</pre>

<div class="english">
<h3 id="init">The init function</h3>
</div>

<h3 id="init函数"><code>init</code> 函数</h3>

<div class="english">
<p>
Finally, each source file can define its own niladic <code>init</code> function to
set up whatever state is required.  (Actually each file can have multiple
<code>init</code> functions.)
And finally means finally: <code>init</code> is called after all the
variable declarations in the package have evaluated their initializers,
and those are evaluated only after all the imported packages have been
initialized.
</p>
</div>

<p>
最后，每个源文件都可以通过定义自己的无参数 <code>init</code> 函数来设置一些必要的状态。
（其实每个文件都可以拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束：
只有该包中的所有变量声明都通过它们的初始化器求值后 <code>init</code> 才会被调用，
而那些 <code>init</code> 只有在所有已导入的包都被初始化后才会被求值。
</p>

<div class="english">
<p>
Besides initializations that cannot be expressed as declarations,
a common use of <code>init</code> functions is to verify or repair
correctness of the program state before real execution begins.
</p>
</div>

<p>
除了那些不能被表示成声明的初始化外，<code>init</code>
函数还常被用在程序真正开始执行前，检验或校正程序的状态。
</p>

<div class="english">
<pre>
func init() {
	if user == "" {
		log.Fatal("$USER not set")
	}
	if home == "" {
		home = "/home/" + user
	}
	if gopath == "" {
		gopath = home + "/go"
	}
	// gopath may be overridden by --gopath flag on command line.
	flag.StringVar(&amp;gopath, "gopath", gopath, "override default GOPATH")
}
</pre>
</div>

<pre>
func init() {
	if user == "" {
		log.Fatal("$USER not set")
	}
	if home == "" {
		home = "/home/" + user
	}
	if gopath == "" {
		gopath = home + "/go"
	}
	// gopath 可通过命令行中的 --gopath 标记覆盖掉。
	flag.StringVar(&amp;gopath, "gopath", gopath, "override default GOPATH")
}
</pre>

<div class="english">
<h2 id="methods">Methods</h2>
</div>

<h2 id="方法">方法</h2>

<div class="english">
<h3 id="pointers_vs_values">Pointers vs. Values</h3>
</div>

<h3 id="指针vs值">指针 vs. 值</h3>

<div class="english">
<p>
As we saw with <code>ByteSize</code>,
methods can be defined for any named type (except a pointer or an interface);
the receiver does not have to be a struct.
</p>
</div>

<p>
正如 <code>ByteSize</code> 那样，我们可以为任何已命名的类型（除了指针或接口）定义方法；
接收者可不必为结构体。
</p>

<div class="english">
<p>
In the discussion of slices above, we wrote an <code>Append</code>
function.  We can define it as a method on slices instead.  To do
this, we first declare a named type to which we can bind the method, and
then make the receiver for the method a value of that type.
</p>
</div>

<p>
在之前讨论切片时，我们编写了一个 <code>Append</code> 函数。
我们也可将其定义为切片的方法。为此，我们首先要声明一个已命名的类型来绑定该方法，
然后使该方法的接收者成为该类型的值。
</p>

<div class="english">
<pre>
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
	// Body exactly the same as above
}
</pre>
</div>

<pre>
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
	// 主体和前面相同。
}
</pre>

<div class="english">
<p>
This still requires the method to return the updated slice.  We can
eliminate that clumsiness by redefining the method to take a
<i>pointer</i> to a <code>ByteSlice</code> as its receiver, so the
method can overwrite the caller's slice.
</p>
</div>

<p>
我们仍然需要该方法返回更新后的切片。为了消除这种不便，我们可通过重新定义该方法，
将一个指向 <code>ByteSlice</code> 的<b>指针</b>作为该方法的接收者，
这样该方法就能重写调用者提供的切片了。
</p>

<div class="english">
<pre>
func (p *ByteSlice) Append(data []byte) {
	slice := *p
	// Body as above, without the return.
	*p = slice
}
</pre>
</div>

<pre>
func (p *ByteSlice) Append(data []byte) {
	slice := *p
	// 主体和前面相同，但没有 return。
	*p = slice
}
</pre>

<div class="english">
<p>
In fact, we can do even better.  If we modify our function so it looks
like a standard <code>Write</code> method, like this,
</p>
</div>

<p>
其实我们做得更好。若我们将函数修改为与标准 <code>Write</code> 类似的方法，就像这样，
</p>

<div class="english">
<pre>
func (p *ByteSlice) Write(data []byte) (n int, err error) {
	slice := *p
	// Again as above.
	*p = slice
	return len(data), nil
}
</pre>
</div>

<pre>
func (p *ByteSlice) Write(data []byte) (n int, err error) {
	slice := *p
	// 依旧和前面相同。
	*p = slice
	return len(data), nil
}
</pre>

<div class="english">
<p>
then the type <code>*ByteSlice</code> satisfies the standard interface
<code>io.Writer</code>, which is handy.  For instance, we can
print into one.
</p>
</div>

<p>
那么类型 <code>*ByteSlice</code> 就满足了标准的 <code>io.Writer</code> 接口，这将非常实用。
例如，我们可以通过打印将内容写入。
</p>

<pre>
	var b ByteSlice
	fmt.Fprintf(&amp;b, "This hour has %d days\n", 7)
</pre>

<div class="english">
<p>
We pass the address of a <code>ByteSlice</code>
because only <code>*ByteSlice</code> satisfies <code>io.Writer</code>.
The rule about pointers vs. values for receivers is that value methods
can be invoked on pointers and values, but pointer methods can only be
invoked on pointers.  This is because pointer methods can modify the
receiver; invoking them on a copy of the value would cause those
modifications to be discarded.
</p>
</div>

<p>
我们将 <code>ByteSlice</code> 的地址传入，因为只有 <code>*ByteSlice</code>
才满足 <code>io.Writer</code>。以指针或值为接收者的区别在于：值方法可通过指针和值调用，
而指针方法只能通过指针来调用。这是由于指针方法可修改接收者，
而在值的副本上所做的修改将被丢弃。
</p>

<div class="english">
<p>
By the way, the idea of using <code>Write</code> on a slice of bytes
is central to the implementation of <code>bytes.Buffer</code>.
</p>
</div>

<p>
顺便一提，在字节切片上使用 <code>Write</code> 的想法已被 <code>bytes.Buffer</code> 所实现。
</p>

<div class="english">
<h2 id="interfaces_and_types">Interfaces and other types</h2>
</div>

<h2 id="接口与类型">接口与其它类型</h2>

<h3 id="接口">接口</h3>

<div class="english">
<p>
Interfaces in Go provide a way to specify the behavior of an
object: if something can do <em>this</em>, then it can be used
<em>here</em>.  We've seen a couple of simple examples already;
custom printers can be implemented by a <code>String</code> method
while <code>Fprintf</code> can generate output to anything
with a <code>Write</code> method.
Interfaces with only one or two methods are common in Go code, and are
usually given a name derived from the method, such as <code>io.Writer</code>
for something that implements <code>Write</code>.
</p>
</div>

<p>
Go中的接口为指定对象的行为提供了一种方法：如果某样东西可以完成<b>这个</b>，
那么它就可以用在<b>这里</b>。我们已经见过许多简单的示例了；通过实现
<code>String</code> 方法，我们可以自定义打印函数，而通过 <code>Write</code>
方法，<code>Fprintf</code> 则能对任何对象产生输出。在Go代码中，
仅包含一两种方法的接口很常见，且其名称通常来自于实现它的方法，
如 <code>io.Writer</code> 就是实现了 <code>Write</code> 的一类对象。
</p>

<div class="english">
<p>
A type can implement multiple interfaces.
For instance, a collection can be sorted
by the routines in package <code>sort</code> if it implements
<code>sort.Interface</code>, which contains <code>Len()</code>,
<code>Less(i, j int) bool</code>, and <code>Swap(i, j int)</code>,
and it could also have a custom formatter.
In this contrived example <code>Sequence</code> satisfies both.
</p>
</div>

<p>
每种类型都能实现多个接口。例如一个实现了 <code>sort.Interface</code> 接口的集合就可通过
<code>sort</code> 包中的例程进行排序。该接口包括 <code>Len()</code>、<code>Less(i, j int) bool</code>
以及 <code>Swap(i, j int)</code>，另外，该集合仍然可以有一个自定义的格式化器。
以下特意构建的例子 <code>Sequence</code> 就同时满足这两种情况。
</p>

{{code "/doc/progs/eff_sequence.go" `/^type/` "$"}}

<div class="english">
<h3 id="conversions">Conversions</h3>
</div>

<h3 id="类型转换">类型转换</h3>

<div class="english">
<p>
The <code>String</code> method of <code>Sequence</code> is recreating the
work that <code>Sprint</code> already does for slices.  We can share the
effort if we convert the <code>Sequence</code> to a plain
<code>[]int</code> before calling <code>Sprint</code>.
</p>
</div>

<p>
<code>Sequence</code> 的 <code>String</code> 方法重新实现了 <code>Sprint</code>
为切片实现的功能。若我们在调用 <code>Sprint</code> 之前将 <code>Sequence</code>
转换为纯粹的 <code>[]int</code>，就能共享已实现的功能。
</p>

<pre>
func (s Sequence) String() string {
	sort.Sort(s)
	return fmt.Sprint([]int(s))
}
</pre>

<div class="english">
<p>
This method is another example of the conversion technique for calling
<code>Sprintf</code> safely from a <code>String</code> method.
Because the two types (<code>Sequence</code> and <code>[]int</code>)
are the same if we ignore the type name, it's legal to convert between them.
The conversion doesn't create a new value, it just temporarily acts
as though the existing value has a new type.
(There are other legal conversions, such as from integer to floating point, that
do create a new value.)
</p>
</div>

<p>
该方法是通过类型转换技术，在 <code>String</code> 方法中安全调用 <code>Sprintf</code>
的另个一例子。若我们忽略类型名的话，这两种类型（<code>Sequence</code>和
<code>[]int</code>）其实是相同的，因此在二者之间进行转换是合法的。
转换过程并不会创建新值，它只是值暂让现有的时看起来有个新类型而已。
（还有些合法转换则会创建新值，如从整数转换为浮点数等。）
</p>

<div class="english">
<p>
It's an idiom in Go programs to convert the
type of an expression to access a different
set of methods. As an example, we could use the existing
type <code>sort.IntSlice</code> to reduce the entire example
to this:
</p>
</div>

<p>
在Go程序中，为访问不同的方法集而进行类型转换的情况非常常见。
例如，我们可使用现有的 <code>sort.IntSlice</code> 类型来简化整个示例：
</p>

<div class="english">
<pre>
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
	sort.IntSlice(s).Sort()
	return fmt.Sprint([]int(s))
}
</pre>
</div>

<pre>
type Sequence []int

// // 用于打印的方法 - 在打印前对元素进行排序。
func (s Sequence) String() string {
	sort.IntSlice(s).Sort()
	return fmt.Sprint([]int(s))
}
</pre>

<div class="english">
<p>
Now, instead of having <code>Sequence</code> implement multiple
interfaces (sorting and printing), we're using the ability of a data item to be
converted to multiple types (<code>Sequence</code>, <code>sort.IntSlice</code>
and <code>[]int</code>), each of which does some part of the job.
That's more unusual in practice but can be effective.
</p>
</div>

<p>
现在，不必让 <code>Sequence</code> 实现多个接口（排序和打印），
我们可通过将数据条目转换为多种类型（<code>Sequence</code>、<code>sort.IntSlice</code>
和 <code>[]int</code>）来使用相应的功能，每次转换都完成一部分工作。
这在实践中虽然有些不同寻常，但往往却很有效。
</p>

<div class="english">
<h3 id="interface_conversions">Interface conversions and type assertions</h3>
</div>

<h3 id="接口转换">接口转换与类型断言</h3>

<div class="english">
<p>
<a href="#type_switch">Type switches</a> are a form of conversion: they take an interface and, for
each case in the switch, in a sense convert it to the type of that case.
Here's a simplified version of how the code under <code>fmt.Printf</code> turns a value into
a string using a type switch.
If it's already a string, we want the actual string value held by the interface, while if it has a
<code>String</code> method we want the result of calling the method.
</p>
</div>

<p>
<a href="#类型选择">类型选择</a>是类型转换的一种形式：它接受一个接口，在选择
（<code>switch</code>）中根据其判断选择对应的情况（<code>case</code>），
并在某种意义上将其转换为该种类型。以下代码为 <code>fmt.Printf</code>
通过类型选择将值转换为字符串的简化版。若它已经为字符串，我们需要该接口中实际的字符串值；
若它有 <code>String</code> 方法，我们则需要调用该方法所得的结果。
</p>

<div class="english">
<pre>
type Stringer interface {
	String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
	return str
case Stringer:
	return str.String()
}
</pre>
</div>

<pre>
type Stringer interface {
	String() string
}

var value interface{} // 调用者提供的值。
switch str := value.(type) {
case string:
	return str
case Stringer:
	return str.String()
}
</pre>

<div class="english">
<p>
The first case finds a concrete value; the second converts the interface into another interface.
It's perfectly fine to mix types this way.
</p>
</div>

<p>
第一种情况获取具体的值，第二种将该接口转换为另一个接口。这种方式对于混合类型来说非常完美。
</p>

<div class="english">
<p>
What if there's only one type we care about? If we know the value holds a <code>string</code>
and we just want to extract it?
A one-case type switch would do, but so would a <em>type assertion</em>.
A type assertion takes an interface value and extracts from it a value of the specified explicit type.
The syntax borrows from the clause opening a type switch, but with an explicit
type rather than the <code>type</code> keyword:
</p>
</div>

<p>
若我们只关心一种类型呢？若我们知道该值拥有一个 <code>string</code> 而想要提取它呢？
只需一种情况的类型选择就行，但它需要<b>类型断言</b>。类型断言接受一个接口值，
并从中提取指定的明确类型的值。其语法借鉴自类型选择开头的子句，但它需要一个明确的类型，
而非 <code>type</code> 关键字：
</p>

<pre>
value.(typeName)
</pre>

<div class="english">
<p>
and the result is a new value with the static type <code>typeName</code>.
That type must either be the concrete type held by the interface, or a second interface
type that the value can be converted to.
To extract the string we know is in the value, we could write:
</p>
</div>

<p>
而其结果则是拥有静态类型 <code>typeName</code> 的新值。该类型必须为该接口所拥有的具体类型，
或者该值可转换成的第二种接口类型。要提取我们知道在该值中的字符串，可以这样：
</p>

<pre>
str := value.(string)
</pre>

<div class="english">
<p>
But if it turns out that the value does not contain a string, the program will crash with a run-time error.
To guard against that, use the "comma, ok" idiom to test, safely, whether the value is a string:
</p>
</div>

<p>
但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况，
需使用“逗号, ok”惯用测试它能安全地判断该值是否为字符串：
</p>

<div class="english">
<pre>
str, ok := value.(string)
if ok {
	fmt.Printf("string value is: %q\n", str)
} else {
	fmt.Printf("value is not a string\n")
}
</pre>
</div>

<pre>
str, ok := value.(string)
if ok {
	fmt.Printf("字符串值为 %q\n", str)
} else {
	fmt.Printf("该值非字符串\n")
}
</pre>

<div class="english">
<p>
If the type assertion fails, <code>str</code> will still exist and be of type string, but it will have
the zero value, an empty string.
</p>
</div>

<p>
若类型断言失败，<code>str</code> 将继续存在且为字符串类型，但它将拥有零值，即空字符串。
</p>

<div class="english">
<p>
As an illustration of the capability, here's an <code>if</code>-<code>else</code>
statement that's equivalent to the type switch that opened this section.
</p>
</div>

<p>
作为对能量的说明，这里有个 <code>if-else</code> 语句，它等价于本节开头的类型选择。
</p>

<pre>
if str, ok := value.(string); ok {
	return str
} else if str, ok := value.(Stringer); ok {
	return str.String()
}
</pre>

<h3 id="通用性">通用性</h3>

<div class="english">
<p>
If a type exists only to implement an interface
and has no exported methods beyond that interface,
there is no need to export the type itself.
Exporting just the interface makes it clear that
it's the behavior that matters, not the implementation,
and that other implementations with different properties
can mirror the behavior of the original type.
It also avoids the need to repeat the documentation
on every instance of a common method.
</p>
</div>

<p>
若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。
仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。
这也能够避免为每个通用接口的实例重复编写文档。
</p>

<div class="english">
<p>
In such cases, the constructor should return an interface value
rather than the implementing type.
As an example, in the hash libraries
both <code>crc32.NewIEEE</code> and <code>adler32.New</code>
return the interface type <code>hash.Hash32</code>.
Substituting the CRC-32 algorithm for Adler-32 in a Go program
requires only changing the constructor call;
the rest of the code is unaffected by the change of algorithm.
</p>
</div>

<p>
在这种情况下，构造函数应当返回一个接口值而非实现的类型。例如在 <code>hash</code>
库中，<code>crc32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型
<code>hash.Hash32</code>。要在Go程序中用Adler-32算法替代CRC-32，
只需修改构造函数调用即可，其余代码则不受算法改变的影响。
</p>

<div class="english">
<p>
A similar approach allows the streaming cipher algorithms
in the various <code>crypto</code> packages to be
separated from the block ciphers they chain together.
The <code>Block</code> interface
in the <code>crypto/cipher</code> package specifies the
behavior of a block cipher, which provides encryption
of a single block of data.
Then, by analogy with the <code>bufio</code> package,
cipher packages that implement this interface
can be used to construct streaming ciphers, represented
by the <code>Stream</code> interface, without
knowing the details of the block encryption.
</p>
</div>

<p>
同样的方式能将 <code>crypto</code> 包中多种联系在一起的流密码算法与块密码算法分开。
<code>crypto/cipher</code> 包中的 <code>Block</code> 接口指定了块密码算法的行为，
它为单独的数据块提供加密。接着，和 <code>bufio</code>
包类似，任何实现了该接口的密码包都能被用于构造以 <code>Stream</code>
为接口表示的流密码，而无需知道块加密的细节。
</p>

<div class="english">
<p>
The  <code>crypto/cipher</code> interfaces look like this:
</p>
</div>

<p>
<code>crypto/cipher</code> 接口看其来就像这样：
</p>

<pre>
type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}

type Stream interface {
	XORKeyStream(dst, src []byte)
}
</pre>

<div class="english">
<p>
Here's the definition of the counter mode (CTR) stream,
which turns a block cipher into a streaming cipher; notice
that the block cipher's details are abstracted away:
</p>
</div>

<p>
这是计数器模式CTR流的定义，它将块加密改为流加密，注意块加密的细节已被抽象化了。
</p>

<div class="english">
<pre>
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
</pre>
</div>

<pre>
// NewCTR 返回一个 Stream，其加密/解密使用计数器模式中给定的 Block 进行。
// iv 的长度必须与 Block 的块大小相同。
func NewCTR(block Block, iv []byte) Stream
</pre>

<div class="english">
<p>
<code>NewCTR</code> applies not
just to one specific encryption algorithm and data source but to any
implementation of the <code>Block</code> interface and any
<code>Stream</code>.  Because they return
interface values, replacing CTR
encryption with other encryption modes is a localized change.  The constructor
calls must be edited, but because the surrounding code must treat the result only
as a <code>Stream</code>, it won't notice the difference.
</p>
</div>

<p>
<code>NewCTR</code> 的应用并不仅限于特定的加密算法和数据源，它适用于任何对
<code>Block</code> 接口和 <code>Stream</code> 的实现。因为它们返回接口值，
所以用其它加密模式来代替CTR只需做局部的更改。构造函数的调用过程必须被修改，
但由于其周围的代码只能将它看做 <code>Stream</code>，因此它们不会注意到其中的区别。
</p>

<div class="english">
<h3 id="interface_methods">Interfaces and methods</h3>
</div>

<h3 id="接口方法">接口和方法</h3>

<div class="english">
<p>
Since almost anything can have methods attached, almost anything can
satisfy an interface.  One illustrative example is in the <code>http</code>
package, which defines the <code>Handler</code> interface.  Any object
that implements <code>Handler</code> can serve HTTP requests.
</p>
</div>

<p>
由于几乎任何类型都能添加方法，因此几乎任何类型都能满足一个接口。一个很直观的例子就是
<code>http</code> 包中定义的 <code>Handler</code> 接口。任何实现了
<code>Handler</code> 的对象都能够处理HTTP请求。
</p>

<pre>
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
</pre>

<div class="english">
<p>
<code>ResponseWriter</code> is itself an interface that provides access
to the methods needed to return the response to the client.
Those methods include the standard <code>Write</code> method, so an
<code>http.ResponseWriter</code> can be used wherever an <code>io.Writer</code>
can be used.
<code>Request</code> is a struct containing a parsed representation
of the request from the client.
</p>
</div>

<p>
<code>ResponseWriter</code> 接口提供了对方法的访问，这些方法需要响应客户端的请求。
由于这些方法包含了标准的 <code>Write</code> 方法，因此 <code>http.ResponseWriter</code>
可用于任何 <code>io.Writer</code> 适用的场景。<code>Request</code>
结构体包含已解析的客户端请求。
</p>

<div class="english">
<p>
For brevity, let's ignore POSTs and assume HTTP requests are always
GETs; that simplification does not affect the way the handlers are
set up.  Here's a trivial but complete implementation of a handler to
count the number of times the
page is visited.
</p>
</div>

<p>
为简单起见，我们假设所有的HTTP请求都是GET方法，而忽略POST方法，
这种简化不会影响处理程序的建立方式。这里有个短小却完整的处理程序实现，
它用于记录某个页面被访问的次数。
</p>

<div class="english">
<pre>
// Simple counter server.
type Counter struct {
	n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	ctr.n++
	fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
</pre>
</div>

<pre>
// 简单的计数器服务。
type Counter struct {
	n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	ctr.n++
	fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
</pre>

<div class="english">
<p>
(Keeping with our theme, note how <code>Fprintf</code> can print to an
<code>http.ResponseWriter</code>.)
For reference, here's how to attach such a server to a node on the URL tree.
</p>
</div>

<p>
（紧跟我们的主题，注意 <code>Fprintf</code> 如何能输出到
<code>http.ResponseWriter</code>。）
作为参考，这里演示了如何将这样一个服务器添加到URL树的一个节点上。
</p>

<pre>
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
</pre>

<div class="english">
<p>
But why make <code>Counter</code> a struct?  An integer is all that's needed.
(The receiver needs to be a pointer so the increment is visible to the caller.)
</p>
</div>

<p>
但为什么 <code>Counter</code> 要是结构体呢？一个整数就够了。  An integer is all that's needed.
（接收者必须为指针，增量操作对于调用者才可见。）
</p>

<div class="english">
<pre>
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	*ctr++
	fmt.Fprintf(w, "counter = %d\n", *ctr)
}
</pre>
</div>

<pre>
// 简单的计数器服务。
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	*ctr++
	fmt.Fprintf(w, "counter = %d\n", *ctr)
}
</pre>

<div class="english">
<p>
What if your program has some internal state that needs to be notified that a page
has been visited?  Tie a channel to the web page.
</p>
</div>

<p>
当页面被访问时，怎样通知你的程序去更新一些内部状态呢？为Web页面绑定个信道吧。
</p>

<div class="english">
<pre>
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	ch &lt;- req
	fmt.Fprint(w, "notification sent")
}
</pre>
</div>

<pre>
// 每次浏览该信道都会发送一个提醒。
// （可能需要带缓冲的信道。）
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	ch &lt;- req
	fmt.Fprint(w, "notification sent")
}
</pre>

<div class="english">
<p>
Finally, let's say we wanted to present on <code>/args</code> the arguments
used when invoking the server binary.
It's easy to write a function to print the arguments.
</p>
</div>

<p>
最后，假设我们需要输出调用服务器二进制程序时使用的实参 <code>/args</code>。
很简单，写个打印实参的函数就行了。
</p>
<pre>
func ArgServer() {
	fmt.Println(os.Args)
}
</pre>

<div class="english">
<p>
How do we turn that into an HTTP server?  We could make <code>ArgServer</code>
a method of some type whose value we ignore, but there's a cleaner way.
Since we can define a method for any type except pointers and interfaces,
we can write a method for a function.
The <code>http</code> package contains this code:
</p>
</div>

<p>
我们如何将它转换为HTTP服务器呢？我们可以将 <code>ArgServer</code>
实现为某种可忽略值的方法，不过还有种更简单的方法。
既然我们可以为除指针和接口以外的任何类型定义方法，同样也能为一个函数写一个方法。
<code>http</code> 包包含以下代码：
</p>

<div class="english">
<pre>
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
	f(w, req)
}
</pre>
</div>

<pre>
// HandlerFunc 类型是一个适配器，它允许将普通函数用做HTTP处理程序。
// 若 f 是个具有适当签名的函数，HandlerFunc(f) 就是个调用 f 的处理程序对象。
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
	f(w, req)
}
</pre>

<div class="english">
<p>
<code>HandlerFunc</code> is a type with a method, <code>ServeHTTP</code>,
so values of that type can serve HTTP requests.  Look at the implementation
of the method: the receiver is a function, <code>f</code>, and the method
calls <code>f</code>.  That may seem odd but it's not that different from, say,
the receiver being a channel and the method sending on the channel.
</p>
</div>

<p>
<code>HandlerFunc</code> 是个具有 <code>ServeHTTP</code> 方法的类型，
因此该类型的值就能处理HTTP请求。我们来看看该方法的实现：接收者是一个函数
<code>f</code>，而该方法调用 <code>f</code>。这看起来很奇怪，但不必大惊小怪，
区别在于接收者变成了一个信道，而方法通过该信道发送消息。
</p>

<div class="english">
<p>
To make <code>ArgServer</code> into an HTTP server, we first modify it
to have the right signature.
</p>
</div>

<p>
为了将 <code>ArgServer</code> 实现成HTTP服务器，首先我们得让它拥有合适的签名。
</p>

<div class="english">
<pre>
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintln(w, os.Args)
}
</pre>
</div>

<pre>
// 实参服务器。
func ArgServer(w http.ResponseWriter, req *http.Request) {
	fmt.Fprintln(w, os.Args)
}
</pre>

<div class="english">
<p>
<code>ArgServer</code> now has same signature as <code>HandlerFunc</code>,
so it can be converted to that type to access its methods,
just as we converted <code>Sequence</code> to <code>IntSlice</code>
to access <code>IntSlice.Sort</code>.
The code to set it up is concise:
</p>
</div>

<p>
<code>ArgServer</code> 和 <code>HandlerFunc</code> 现在拥有了相同的签名，
因此我们可将其转换为这种类型以访问它的方法，就像我们将 <code>Sequence</code>
转换为 <code>IntSlice</code> 以访问 <code>IntSlice.Sort</code> 那样。
建立代码非常简单：
</p>
<pre>
http.Handle("/args", http.HandlerFunc(ArgServer))
</pre>

<div class="english">
<p>
When someone visits the page <code>/args</code>,
the handler installed at that page has value <code>ArgServer</code>
and type <code>HandlerFunc</code>.
The HTTP server will invoke the method <code>ServeHTTP</code>
of that type, with <code>ArgServer</code> as the receiver, which will in turn call
<code>ArgServer</code> (via the invocation <code>f(c, req)</code>
inside <code>HandlerFunc.ServeHTTP</code>).
The arguments will then be displayed.
</p>
</div>

<p>
当有人访问 <code>/args</code> 页面时，安装到该页面的处理程序就有了值
<code>ArgServer</code> 和类型 <code>HandlerFunc</code>。
HTTP服务器会以 <code>ArgServer</code> 为接收者，调用该类型的
<code>ServeHTTP</code> 方法，它会反过来调用 <code>ArgServer</code>（通过
<code>f(c, req)</code>），接着实参就会被显示出来。
</p>

<div class="english">
<p>
In this section we have made an HTTP server from a struct, an integer,
a channel, and a function, all because interfaces are just sets of
methods, which can be defined for (almost) any type.
</p>
</div>

<p>
在本节中，我们通过一个结构体，一个整数，一个信道和一个函数，建立了一个HTTP服务器，
这一切都是因为接口只是方法的集和，而几乎任何类型都能定义方法。
</p>

<div class="english">
<h2 id="blank">The blank identifier</h2>
</div>

<h2 id="空白">空白标识符</h2>

<div class="english">
<p>
We've mentioned the blank identifier a couple of times now, in the context of
<a href="#for"><code>for</code> <code>range</code> loops</a>
and <a href="#maps">maps</a>.
The blank identifier can be assigned or declared with any value of any type, with the
value discarded harmlessly.
It's a bit like writing to the Unix <code>/dev/null</code> file:
it represents a write-only value
to be used as a place-holder
where a variable is needed but the actual value is irrelevant.
It has uses beyond those we've seen already.
</p>
</div>

<p>
我们在 <a href="#for"><code>for-range</code> 循环</a>和<a href="#映射">映射</a>中提过几次空白标识符。
空白标识符可被赋予或声明为任何类型的任何值，而其值会被无害地丢弃。它有点像Unix中的
<code>/dev/null</code> 文件：它表示只写的值，在需要变量但不需要实际值的地方用作占位符。
我们在前面已经见过它的用法了。
</p>

<div class="english">
<h3 id="blank_assign">The blank identifier in multiple assignment</h3>
</div>

<h3 id="空白赋值">多重赋值中的空白标识符</h3>

<div class="english">
<p>
The use of a blank identifier in a <code>for</code> <code>range</code> loop is a
special case of a general situation: multiple assignment.
</p>
</div>

<p>
<code>for range</code> 循环中对空表标识符的用法是一种具体情况，更一般的情况即为多重赋值。
</p>

<div class="english">
<p>
If an assignment requires multiple values on the left side,
but one of the values will not be used by the program,
a blank identifier on the left-hand-side of
the assignment avoids the need
to create a dummy variable and makes it clear that the
value is to be discarded.
For instance, when calling a function that returns
a value and an error, but only the error is important,
use the blank identifier to discard the irrelevant value.
</p>
</div>

<p>
若某次赋值需要匹配多个左值，但其中某个变量不会被程序使用，
那么用空白标识符来代替该变量可避免创建无用的变量，并能清楚地表明该值将被丢弃。
例如，当调用某个函数时，它会返回一个值和一个错误，但只有错误很重要，
那么可使用空白标识符来丢弃无关的值。
</p>

<pre>
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
</pre>

<div class="english">
<p>
Occasionally you'll see code that discards the error value in order
to ignore the error; this is terrible practice. Always check error returns;
they're provided for a reason.
</p>
</div>

<p>
你偶尔会看见为忽略错误而丢弃错误值的代码，这是种糟糕的实践。请务必检查错误返回，
它们会提供错误的理由。
</p>

<div class="english">
<pre>
// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
	fmt.Printf("%s is a directory\n", path)
}
</pre>
</div>

<pre>
// 烂代码！若路径不存在，它就会崩溃。
fi, _ := os.Stat(path)
if fi.IsDir() {
	fmt.Printf("%s is a directory\n", path)
}
</pre>

<div class="english">
<h3 id="blank_unused">Unused imports and variables</h3>
</div>

<h3 id="空白未使用">未使用的导入和变量</h3>

<div class="english">
<p>
It is an error to import a package or to declare a variable without using it.
Unused imports bloat the program and slow compilation,
while a variable that is initialized but not used is at least
a wasted computation and perhaps indicative of a
larger bug.
When a program is under active development, however,
unused imports and variables often arise and it can
be annoying to delete them just to have the compilation proceed,
only to have them be needed again later.
The blank identifier provides a workaround.
</p>
</div>

<p>
若导入某个包或声明某个变量而不使用它就会产生错误。未使用的包会让程序膨胀并拖慢编译速度，
而已初始化但未使用的变量不仅会浪费计算能力，还有可能暗藏着更大的Bug。
然而在程序开发过程中，经常会产生未使用的导入和变量。虽然以后会用到它们，
但为了完成编译又不得不删除它们才行，这很让人烦恼。空白标识符就能提供一个工作空间。
</p>

<div class="english">
<p>
This half-written program has two unused imports
(<code>fmt</code> and <code>io</code>)
and an unused variable (<code>fd</code>),
so it will not compile, but it would be nice to see if the
code so far is correct.
</p>
</div>

<p>
这个写了一半的程序有两个未使用的导入（<code>fmt</code> 和
<code>io</code>）以及一个未使用的变量（<code>fd</code>），因此它不能编译，
但若到目前为止代码还是正确的，我们还是很乐意看到它们的。
</p>

{{code "/doc/progs/eff_unused1.go" `/package/` `$`}}

<div class="english">
<p>
To silence complaints about the unused imports, use a
blank identifier to refer to a symbol from the imported package.
Similarly, assigning the unused variable <code>fd</code>
to the blank identifier will silence the unused variable error.
This version of the program does compile.
</p>
</div>

<p>
要让编译器停止关于未使用导入的抱怨，需要空白标识符来引用已导入包中的符号。
同样，将未使用的变量 <code>fd</code> 赋予空白标识符也能关闭未使用变量错误。
该程序的以下版本可以编译。
</p>

{{code "/doc/progs/eff_unused2.go" `/package/` `$`}}

<div class="english">
<p>
By convention, the global declarations to silence import errors
should come right after the imports and be commented,
both to make them easy to find and as a reminder to clean things up later.
</p>
</div>

<p>
按照惯例，我们应在导入并加以注释后，再使全局声明导入错误静默，这样可以让它们更易找到，
并作为以后清理它的提醒。
</p>

<div class="english">
<h3 id="blank_import">Import for side effect</h3>
</div>

<h3 id="空白导入">为副作用而导入</h3>

<div class="english">
<p>
An unused import like <code>fmt</code> or <code>io</code> in the
previous example should eventually be used or removed:
blank assignments identify code as a work in progress.
But sometimes it is useful to import a package only for its
side effects, without any explicit use.
For example, during its <code>init</code> function,
the <code><a href="/pkg/net/http/pprof/">net/http/pprof</a></code>
package registers HTTP handlers that provide
debugging information. It has an exported API, but
most clients need only the handler registration and
access the data through a web page.
To import the package only for its side effects, rename the package
to the blank identifier:
</p>
</div>

<p>
像前例中 <code>fmt</code> 或 <code>io</code> 这种未使用的导入总应在最后被使用或移除：
空白赋值会将代码标识为工作正在进行中。但有时导入某个包只是为了其副作用，
而没有任何明确的使用。例如，在 <code><a href="/pkg/net/http/pprof/">net/http/pprof</a></code>
包的 <code>init</code> 函数中记录了HTTP处理程序的调试信息。它有个可导出的API，
但大部分客户端只需要该处理程序的记录和通过Web叶访问数据。只为了其副作用来哦导入该包，
只需将包重命名为空白标识符：
</p>

<pre>
import _ "net/http/pprof"
</pre>

<div class="english">
<p>
This form of import makes clear that the package is being
imported for its side effects, because there is no other possible
use of the package: in this file, it doesn't have a name.
(If it did, and we didn't use that name, the compiler would reject the program.)
</p>
</div>

<p>
这种导入格式能明确表示该包是为其副作用而导入的，因为没有其它使用该包的可能：
在此文件中，它没有名字。（若它有名字而我们没有使用，编译器就会拒绝该程序。）
</p>

<div class="english">
<h3 id="blank_implements">Interface checks</h3>
</div>

<h3 id="空白实现">接口检查</h3>

<div class="english">
<p>
As we saw in the discussion of <a href="#interfaces_and_types">interfaces</a> above,
a type need not declare explicitly that it implements an interface.
Instead, a type implements the interface just by implementing the interface's methods.
In practice, most interface conversions are static and therefore checked at compile time.
For example, passing an <code>*os.File</code> to a function
expecting an <code>io.Reader</code> will not compile unless
<code>*os.File</code> implements the <code>io.Reader</code> interface.
</p>
</div>

<p>
就像我们在前面<a href="#接口与类型">接口</a>中讨论的那样，
一个类型无需显式地声明它实现了某个接口。取而代之，该类型只要实现了某个接口的方法，
其实就实现了该接口。在实践中，大部分接口转换都是静态的，因此会在编译时检测。
例如，将一个 <code>*os.File</code> 传入一个预期的 <code>io.Reader</code> 函数将不会被编译，
除非 <code>*os.File</code> 实现了 <code>io.Reader</code> 接口。
</p>

<div class="english">
<p>
Some interface checks do happen at run-time, though.
One instance is in the <code><a href="/pkg/encoding/json/">encoding/json</a></code>
package, which defines a <code><a href="/pkg/encoding/json/#Marshaler">Marshaler</a></code>
interface. When the JSON encoder receives a value that implements that interface,
the encoder invokes the value's marshaling method to convert it to JSON
instead of doing the standard conversion.
The encoder checks this property at run time with a <a href="#interface_conversions">type assertion</a> like:
</p>
</div>

<p>
尽管有些接口检查会在运行时进行。<code><a href="/pkg/encoding/json/">encoding/json</a></code>
包中就有个实例它定义了一个 <code><a href="/pkg/encoding/json/#Marshaler">Marshaler</a></code>
接口。当JSON编码器接收到一个实现了该接口的值，那么该编码器就会调用该值的编组方法，
将其转换为JSON，而非进行标准的类型转换。
编码器在运行时通过<a href="#接口转换">类型断言</a>检查其属性，就像这样：
</p>

<pre>
m, ok := val.(json.Marshaler)
</pre>

<div class="english">
<p>
If it's necessary only to ask whether a type implements an interface, without
actually using the interface itself, perhaps as part of an error check, use the blank
identifier to ignore the type-asserted value:
</p>
</div>

<p>
若只需要判断某个类型是否是实现了某个接口，而不需要实际使用接口本身
（可能是错误检查部分），就使用空白标识符来忽略类型断言的值：
</p>

<pre>
if _, ok := val.(json.Marshaler); ok {
	fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
</pre>

<div class="english">
<p>
One place this situation arises is when it is necessary to guarantee within the package implementing the type that
it actually satisfies the interface.
If a type—for example,
<code><a href="/pkg/encoding/json/#RawMessage">json.RawMessage</a></code>—needs
a custom JSON representation, it should implement
<code>json.Marshaler</code>, but there are no static conversions that would
cause the compiler to verify this automatically.
If the type inadvertently fails to satisfy the interface, the JSON encoder will still work,
but will not use the custom implementation.
To guarantee that the implementation is correct,
a global declaration using the blank identifier can be used in the package:
</p>
</div>

<p>
当需要确保某个包中实现的类型一定满足该接口时，就会遇到这种情况。
若某个类型（例如 <code><a href="/pkg/encoding/json/#RawMessage">json.RawMessage</a></code>）
需要一种定制的JSON表现时，它应当实现 <code>json.Marshaler</code>，
不过现在没有静态转换可以让编译器去自动验证它。若该类型通过忽略转换失败来满足该接口，
那么JSON编码器仍可工作，但它却不会使用定制的实现。为确保其实现正确，
可在该包中用空白标识符声明一个全局变量：
</p>

<pre>
var _ json.Marshaler = (*RawMessage)(nil)
</pre>

<div class="english">
<p>
In this declaration, the assignment involving a conversion of a
<code>*RawMessage</code> to a <code>Marshaler</code>
requires that <code>*RawMessage</code> implements <code>Marshaler</code>,
and that property will be checked at compile time.
Should the <code>json.Marshaler</code> interface change, this package
will no longer compile and we will be on notice that it needs to be updated.
</p>
</div>

<p>
在此声明中，我们调用了一个 <code>*RawMessage</code> 转换并将其赋予了
<code>Marshaler</code>，以此来要求 <code>*RawMessage</code> 实现
<code>Marshaler</code>，这时其属性就会在编译时被检测。
若 <code>json.Marshaler</code> 接口被更改，此包将无法通过编译，
而我们则会注意到它需要更新。
</p>

<div class="english">
<p>
The appearance of the blank identifier in this construct indicates that
the declaration exists only for the type checking,
not to create a variable.
Don't do this for every type that satisfies an interface, though.
By convention, such declarations are only used
when there are no static conversions already present in the code,
which is a rare event.
</p>
</div>

<p>
在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。
不过请不要为满足接口就将它用于任何类型。作为约定，
仅当代码中不存在静态类型转换时才能这种声明，毕竟这是种罕见的情况。
</p>


<div class="english">
<h2 id="embedding">Embedding</h2>
</div>

<h2 id="内嵌">内嵌</h2>

<div class="english">
<p>
Go does not provide the typical, type-driven notion of subclassing,
but it does have the ability to &ldquo;borrow&rdquo; pieces of an
implementation by <em>embedding</em> types within a struct or
interface.
</p>
</div>

<p>
Go并不提供典型的，类型驱动的子类化概念，但通过将类型<<b>内嵌</b>到结构体或接口中，
它就能“借鉴”部分实现。
</p>

<div class="english">
<p>
Interface embedding is very simple.
We've mentioned the <code>io.Reader</code> and <code>io.Writer</code> interfaces before;
here are their definitions.
</p>
</div>

<p>
接口内嵌非常简单。我们之前提到过 <code>io.Reader</code> 和 <code>io.Writer</code>
接口，这里是它们的定义。
</p>

<pre>
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
</pre>

<div class="english">
<p>
The <code>io</code> package also exports several other interfaces
that specify objects that can implement several such methods.
For instance, there is <code>io.ReadWriter</code>, an interface
containing both <code>Read</code> and <code>Write</code>.
We could specify <code>io.ReadWriter</code> by listing the
two methods explicitly, but it's easier and more evocative
to embed the two interfaces to form the new one, like this:
</p>
</div>

<p>
<code>io</code> 包也导出了一些其它接口，以此来阐明对象所需实现的方法。
例如 <code>io.ReadWriter</code> 就是个包含 <code>Read</code> 和 <code>Write</code>
的接口。我们可以通过显示地列出这两个方法来指明 <code>io.ReadWriter</code>，
但通过将这两个接口内嵌到新的接口中显然更容易且更具启发性，就像这样：
</p>

<div class="english">
<pre>
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
	Reader
	Writer
}
</pre>
</div>

<pre>
// ReadWriter 接口结合了 Reader 和 Writer 接口。
type ReadWriter interface {
	Reader
	Writer
}
</pre>

<div class="english">
<p>
This says just what it looks like: A <code>ReadWriter</code> can do
what a <code>Reader</code> does <em>and</em> what a <code>Writer</code>
does; it is a union of the embedded interfaces (which must be disjoint
sets of methods).
Only interfaces can be embedded within interfaces.
</p>
</div>

<p>
正如它看起来那样：<code>ReadWriter</code> 能够做任何 <code>Reader</code>
<b>和</b> <code>Writer</code> 可以做到的事情，它是内嵌接口的联合体
（它们必须是不相交的方法集）。只有接口能被嵌入到接口中。
</p>

<div class="english">
<p>
The same basic idea applies to structs, but with more far-reaching
implications.  The <code>bufio</code> package has two struct types,
<code>bufio.Reader</code> and <code>bufio.Writer</code>, each of
which of course implements the analogous interfaces from package
<code>io</code>.
And <code>bufio</code> also implements a buffered reader/writer,
which it does by combining a reader and a writer into one struct
using embedding: it lists the types within the struct
but does not give them field names.
</p>
</div>

<p>
同样的基本想法可以应用在结构体中，但其意义更加深远。<code>bufio</code>
包中有 <code>bufio.Reader</code> 和 <code>bufio.Writer</code> 这两个结构体类型，
它们每一个都实现了与 <code>io</code> 包中相同意义的接口。此外，<code>bufio</code>
还通过结合 <code>reader/writer</code> 并将其内嵌到结构体中，实现了带缓冲的
<code>reader/writer</code>：它列出了结构体中的类型，但并未给予它们字段名。
</p>

<div class="english">
<pre>
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
	*Reader  // *bufio.Reader
	*Writer  // *bufio.Writer
}
</pre>
</div>

<pre>
// ReadWriter 存储了指向 Reader 和 Writer 的指针。
// 它实现了 io.ReadWriter。
type ReadWriter struct {
	*Reader  // *bufio.Reader
	*Writer  // *bufio.Writer
}
</pre>

<div class="english">
<p>
The embedded elements are pointers to structs and of course
must be initialized to point to valid structs before they
can be used.
The <code>ReadWriter</code> struct could be written as
</p>
</div>

<p>
内嵌的元素为指向结构体的指针，当然它们在使用前必须被初始化为指向有效结构体的指针。
<code>ReadWriter</code> 结构体和通过如下方式定义：
</p>

<pre>
type ReadWriter struct {
	reader *Reader
	writer *Writer
}
</pre>

<div class="english">
<p>
but then to promote the methods of the fields and to
satisfy the <code>io</code> interfaces, we would also need
to provide forwarding methods, like this:
</p>
</div>

<p>
但为了提升该字段的方法并满足 <code>io</code> 接口，我们同样需要提供转发的方法，
就像这样：
</p>

<pre>
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
	return rw.reader.Read(p)
}
</pre>

<div class="english">
<p>
By embedding the structs directly, we avoid this bookkeeping.
The methods of embedded types come along for free, which means that <code>bufio.ReadWriter</code>
not only has the methods of <code>bufio.Reader</code> and <code>bufio.Writer</code>,
it also satisfies all three interfaces:
<code>io.Reader</code>,
<code>io.Writer</code>, and
<code>io.ReadWriter</code>.
</p>
</div>

<p>
而通过直接内嵌结构体，我们就能避免如此繁琐。
内嵌类型的方法可以直接引用，这意味着 <code>bufio.ReadWriter</code> 不仅包括
<code>bufio.Reader</code> 和 <code>bufio.Writer</code> 的方法，它还同时满足下列三个接口：
<code>io.Reader</code>、<code>io.Writer</code> 以及 <code>io.ReadWriter</code>。
</p>

<div class="english">
<p>
There's an important way in which embedding differs from subclassing.  When we embed a type,
the methods of that type become methods of the outer type,
but when they are invoked the receiver of the method is the inner type, not the outer one.
In our example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is
invoked, it has exactly the same effect as the forwarding method written out above;
the receiver is the <code>reader</code> field of the <code>ReadWriter</code>, not the
<code>ReadWriter</code> itself.
</p>
</div>

<p>
还有种区分内嵌与子类的重要手段。当内嵌一个类型时，该类型的方法会成为外部类型的方法，
但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当
<code>bufio.ReadWriter</code> 的 <code>Read</code> 方法被调用时，
它与之前写的转发方法具有同样的效果；接收者是 <code>ReadWriter</code> 的 <code>reader</code>
字段，而非 <code>ReadWriter</code> 本身。
</p>

<div class="english">
<p>
Embedding can also be a simple convenience.
This example shows an embedded field alongside a regular, named field.
</p>
</div>

<p>
内嵌同样可以提供便利。这个例子展示了一个内嵌字段和一个常规的命名字段。
</p>

<pre>
type Job struct {
	Command string
	*log.Logger
}
</pre>

<div class="english">
<p>
The <code>Job</code> type now has the <code>Log</code>, <code>Logf</code>
and other
methods of <code>*log.Logger</code>.  We could have given the <code>Logger</code>
a field name, of course, but it's not necessary to do so.  And now, once
initialized, we can
log to the <code>Job</code>:
</p>
</div>

<p>
<code>Job</code> 类型现在有了 <code>Log</code>、<code>Logf</code> 和
<code>*log.Logger</code> 的其它方法。我们当然可以为 <code>Logger</code>
提供一个字段名，但完全不必这么做。现在，一旦初始化后，我们就能记录 <code>Job</code> 了：
</p>

<pre>
job.Log("starting now...")
</pre>

<div class="english">
<p>
The <code>Logger</code> is a regular field of the <code>Job</code> struct,
so we can initialize it in the usual way inside the constructor for <code>Job</code>, like this,
</p>
</div>

<p>
<code>Logger</code> 是 <code>Job</code> 结构体的常规字段，
因此我们可在 <code>Job</code> 的构造函数中，通过一般的方式来初始化它，就像这样：
</p>

<pre>
func NewJob(command string, logger *log.Logger) *Job {
	return &amp;Job{command, logger}
}
</pre>

<div class="english">
<p>
or with a composite literal,
</p>
</div>

<p>
或通过复合字面：
</p>

<pre>
job := &amp;Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
</pre>

<div class="english">
<p>
If we need to refer to an embedded field directly, the type name of the field,
ignoring the package qualifier, serves as a field name, as it did
in the <code>Read</code> method of our <code>ReaderWriter</code> struct.
Here, if we needed to access the
<code>*log.Logger</code> of a <code>Job</code> variable <code>job</code>,
we would write <code>job.Logger</code>,
which would be useful if we wanted to refine the methods of <code>Logger</code>.
</p>
</div>

<p>
若我们需要直接引用内嵌字段，可以忽略包限定名，直接将该字段的类型名作为字段名，
就像我们在 <code>ReaderWriter</code> 结构体的 <code>Read</code> 方法中做的那样。
若我们需要访问 <code>Job</code> 类型的变量 <code>job</code> 的 <code>*log.Logger</code>，
可以直接写作 <code>job.Logger</code>。若我们想精炼 <code>Logger</code> 的方法时，
这会非常有用。
</p>

<pre>
func (job *Job) Logf(format string, args ...interface{}) {
	job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
</pre>

<div class="english">
<p>
Embedding types introduces the problem of name conflicts but the rules to resolve
them are simple.
First, a field or method <code>X</code> hides any other item <code>X</code> in a more deeply
nested part of the type.
If <code>log.Logger</code> contained a field or method called <code>Command</code>, the <code>Command</code> field
of <code>Job</code> would dominate it.
</p>
</div>

<p>
内嵌类型会引入命名冲突的问题，但解决规则却很简单。首先，字段或方法 <code>X</code>
会隐藏该类型中更深层嵌套的其它项 <code>X</code>。若 <code>log.Logger</code>
包含一个名为 <code>Command</code> 的字段或方法，<code>Job</code> 的 <code>Command</code>
字段会覆盖它。
</p>

<div class="english">
<p>
Second, if the same name appears at the same nesting level, it is usually an error;
it would be erroneous to embed <code>log.Logger</code> if the <code>Job</code> struct
contained another field or method called <code>Logger</code>.
However, if the duplicate name is never mentioned in the program outside the type definition, it is OK.
This qualification provides some protection against changes made to types embedded from outside; there
is no problem if a field is added that conflicts with another field in another subtype if neither field
is ever used.
</p>
</div>

<p>
其次，若相同的嵌套层级上出现同名冲突，通常会产生一个错误。若 <code>Job</code>
结构体中包含名为 <code>Logger</code> 的字段或方法，再将 <code>log.Logger</code>
内嵌到其中的话就会产生错误。然而，若重名永远不会在该类型定义之外的程序中使用，那就不会出错。
这种限定能够在外部嵌套类型发生修改时提供某种保护。
因此，就算添加的字段与另一个子类型中的字段相冲突，只要这两个相同的字段永远不会被使用就没问题。
</p>


<div class="english">
<h2 id="concurrency">Concurrency</h2>
</div>

<h2 id="并发">并发</h2>

<div class="english">
<h3 id="sharing">Share by communicating</h3>
</div>

<h3 id="共享">通过通信共享内存</h3>

<div class="english">
<p>
Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.
</p>
</div>

<p>
并发编程是个很大的论题。但限于篇幅，这里仅讨论一些Go特有的东西。
</p>

<div class="english">
<p>
Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables.  Go encourages
a different approach in which shared values are passed around on channels
and, in fact, never actively shared by separate threads of execution.
Only one goroutine has access to the value at any given time.
Data races cannot occur, by design.
To encourage this way of thinking we have reduced it to a slogan:
</p>
</div>

<p>
在并发编程中，为实现对共享变量的正确访问需要精确的控制，这在多数环境下都很困难。
Go语言另辟蹊径，它将共享的值通过信道传递，实际上，多个独立执行的线程从不会主动共享。
在任意给定的时间点，只有一个Go程能够访问该值。数据竞争从设计上就被杜绝了。
为了提倡这种思考方式，我们将它简化为一句口号：
</p>

<div class="english">
<blockquote>
Do not communicate by sharing memory;
instead, share memory by communicating.
</blockquote>
</div>

<blockquote>
不要通过共享内存来通信，而应通过通信来共享内存。
</blockquote>

<div class="english">
<p>
This approach can be taken too far.  Reference counts may be best done
by putting a mutex around an integer variable, for instance.  But as a
high-level approach, using channels to control access makes it easier
to write clear, correct programs.
</p>
</div>

<p>
这种方法意义深远。例如，引用计数通过为整数变量添加互斥锁来很好地实现。
但作为一种高级方法，通过信道来控制访问能够让你写出更简洁，正确的程序。
</p>

<div class="english">
<p>
One way to think about this model is to consider a typical single-threaded
program running on one CPU. It has no need for synchronization primitives.
Now run another such instance; it too needs no synchronization.  Now let those
two communicate; if the communication is the synchronizer, there's still no need
for other synchronization.  Unix pipelines, for example, fit this model
perfectly.  Although Go's approach to concurrency originates in Hoare's
Communicating Sequential Processes (CSP),
it can also be seen as a type-safe generalization of Unix pipes.
</p>
</div>

<p>
我们可以从典型的单线程运行在单CPU之上的情形来审视这种模型。它无需提供同步原语。
现在考虑另一种情况，它也无需同步。现在让它们俩进行通信。若将通信过程看做同步着，
那就完全不需要其它同步了。例如，Unix管道就与这种模型完美契合。
尽管Go的并发处理方式来源于Hoare的通信顺序处理（CSP），
它依然可以看做是类型安全的Unix管道的实现。
</p>

<div class="english">
<h3 id="goroutines">Goroutines</h3>
</div>

<h3 id="Go程">Go程</h3>

<div class="english">
<p>
They're called <em>goroutines</em> because the existing
terms&mdash;threads, coroutines, processes, and so on&mdash;convey
inaccurate connotations.  A goroutine has a simple model: it is a
function executing concurrently with other goroutines in the same
address space.  It is lightweight, costing little more than the
allocation of stack space.
And the stacks start small, so they are cheap, and grow
by allocating (and freeing) heap storage as required.
</p>
</div>

<p>
我们称之为<b>Go程</b>是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。
Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，
所有小号几乎就只有栈空间的分配。而且栈最开始是非常小的，所以它们很廉价，
仅在需要时才会随着堆空间的分配（和释放）而变化。
</p>

<div class="english">
<p>
Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run.  Their
design hides many of the complexities of thread creation and
management.
</p>
</div>

<p>
Go程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待I/O，
那么其它的线程就会运行。Go程的设计隐藏了线程创建和管理的诸多复杂性。
</p>

<div class="english">
<p>
Prefix a function or method call with the <code>go</code>
keyword to run the call in a new goroutine.
When the call completes, the goroutine
exits, silently.  (The effect is similar to the Unix shell's
<code>&amp;</code> notation for running a command in the
background.)
</p>
</div>

<p>
在函数或方法前添加 <code>go</code> 关键字能够在新的Go程中调用它。当调用完成后，
该Go程也会安静地退出。（效果有点像Unix Shell中的 <code>&amp;</code>
符号，它能让命令在后台运行。）
</p>

<div class="english">
<pre>
go list.Sort()  // run list.Sort concurrently; don't wait for it.
</pre>
</div>

<pre>
go list.Sort()  // 并发运行 list.Sort，无需等它结束。
</pre>

<div class="english">
<p>
A function literal can be handy in a goroutine invocation.
</p>
</div>

<p>
函数字面在Go程调用中非常有用。
</p>

<div class="english">
<pre>
func Announce(message string, delay time.Duration) {
	go func() {
		time.Sleep(delay)
		fmt.Println(message)
	}()  // Note the parentheses - must call the function.
}
</pre>
</div>

<pre>
func Announce(message string, delay time.Duration) {
	go func() {
		time.Sleep(delay)
		fmt.Println(message)
	}()  // 注意括号 - 必须调用该函数。
}
</pre>

<div class="english">
<p>
In Go, function literals are closures: the implementation makes
sure the variables referred to by the function survive as long as they are active.
</p>
</div>

<p>
在Go中，函数字面都是闭包：其实现在保证了函数内引用变量的生命周期与函数的活动时间相同。
</p>

<div class="english">
<p>
These examples aren't too practical because the functions have no way of signaling
completion.  For that, we need channels.
</p>
</div>

<p>
这些函数没什么实用性，因为它们没有实现完成时的信号处理。因此，我们需要信道。
</p>

<div class="english">
<h3 id="channels">Channels</h3>
</div>

<h3 id="信道">信道</h3>

<div class="english">
<p>
Like maps, channels are allocated with <code>make</code>, and
the resulting value acts as a reference to an underlying data structure.
If an optional integer parameter is provided, it sets the buffer size for the channel.
The default is zero, for an unbuffered or synchronous channel.
</p>
</div>

<p>
信道与映射一样，也需要通过 <code>make</code> 来分配内存。其结果值充当了对底层数据结构的引用。
若提供了一个可选的整数形参，它就会为该信道设置缓冲区大小。默认值是零，表示不带缓冲的或同步的信道。
</p>

<div class="english">
<pre>
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
</pre>
</div>

<pre>
ci := make(chan int)            // 整数类型的无缓冲信道
cj := make(chan int, 0)         // 整数类型的无缓冲信道
cs := make(chan *os.File, 100)  // 指向文件指针的带缓冲信道
</pre>

<div class="english">
<p>
Unbuffered channels combine communication&mdash;the exchange of a value&mdash;with
synchronization&mdash;guaranteeing that two calculations (goroutines) are in
a known state.
</p>
</div>

<p>
无缓冲信道在通信时会同步交换数据，它能确保（两个Go程的）计算处于确定状态。
</p>

<div class="english">
<p>
There are lots of nice idioms using channels.  Here's one to get us started.
In the previous section we launched a sort in the background. A channel
can allow the launching goroutine to wait for the sort to complete.
</p>
</div>

<p>
信道有很多惯用法，我们从这里开始了解。在上一节中，我们在后台启动了排序操作。
信道使得启动的Go程等待排序完成。
</p>

<div class="english">
<pre>
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
	list.Sort()
	c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c   // Wait for sort to finish; discard sent value.
</pre>
</div>

<pre>
c := make(chan int)  // 分配一个信道
// 在Go程中启动排序。当它完成后，在信道上发送信号。
go func() {
	list.Sort()
	c &lt;- 1  // 发送信号，什么值无所谓。
}()
doSomethingForAWhile()
&lt;-c   // 等待排序结束，丢弃发来的值。
</pre>

<div class="english">
<p>
Receivers always block until there is data to receive.
If the channel is unbuffered, the sender blocks until the receiver has
received the value.
If the channel has a buffer, the sender blocks only until the
value has been copied to the buffer; if the buffer is full, this
means waiting until some receiver has retrieved a value.
</p>
</div>

<p>
接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前，
发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞；
若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。
</p>

<div class="english">
<p>
A buffered channel can be used like a semaphore, for instance to
limit throughput.  In this example, incoming requests are passed
to <code>handle</code>, which receives a value from the channel, processes
the request, and then sends a value back to the channel
to ready the "semaphore" for the next consumer.
The capacity of the channel buffer limits the number of
simultaneous calls to <code>process</code>,
so during initialization we prime the channel by filling it to capacity.
</p>
</div>

<p>
带缓冲的信道可被用作信号量，例如限制吞吐量。在此例中，进入的请求会被传递给
<code>handle</code>，它从信道中接收值，处理请求后将值发回该信道中，以便让该
“信号量”准备迎接下一次请求。信道缓冲区的容量决定了同时调用 <code>process</code>
的数量上限，因此我们在初始化时首先要填充至它的容量上限。
</p>

<div class="english">
<pre>
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
	&lt;-sem          // Wait for active queue to drain.
	process(r)     // May take a long time.
	sem &lt;- 1       // Done; enable next request to run.
}

func init() {
	for i := 0; i &lt; MaxOutstanding; i++ {
		sem &lt;- 1
	}
}

func Serve(queue chan *Request) {
	for {
		req := &lt;-queue
		go handle(req)  // Don't wait for handle to finish.
	}
}
</pre>
</div>

<pre>
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
	&lt;-sem    // 等待活动队列清空。
	process(r)  // 可能需要很长时间。
	sem &lt;- 1 // 完成；使下一个请求可以运行。
}

func init() {
	for i := 0; i &lt; MaxOutstanding; i++ {
		sem &lt;- 1
	}
}

func Serve(queue chan *Request) {
	for {
		req := &lt;-queue
		go handle(req)  // 无需等待 handle 结束。
	}
}
</pre>

<div class="english">
<p>
Because data synchronization occurs on a receive from a channel
(that is, the send "happens before" the receive; see
<a href="/ref/mem">The Go Memory Model</a>),
acquisition of the semaphore must be on a channel receive, not a send.
</p>
</div>

<p>
由于数据同步发生在信道的接收端（也就是说发送<b>发生在</b>>接受<b>之前</b>，参见
<a href="/ref/mem">Go内存模型</a>），因此信号必须在信道的接收端获取，而非发送端。
</p>

<div class="english">
<p>
This design has a problem, though: <code>Serve</code>
creates a new goroutine for
every incoming request, even though only <code>MaxOutstanding</code>
of them can run at any moment.
As a result, the program can consume unlimited resources if the requests come in too fast.
We can address that deficiency by changing <code>Serve</code> to
gate the creation of the goroutines.
Here's an obvious solution, but beware it has a bug we'll fix subsequently:
</p>
</div>

<p>
然而，它却有个设计问题：尽管只有 <code>MaxOutstanding</code> 个Go程能同时运行，但
<code>Serve</code> 还是为每个进入的请求都创建了新的Go程。其结果就是，若请求来得很快，
该程序就会无限地消耗资源。为了弥补这种不足，我们可以通过修改 <code>Serve</code>
来限制创建Go程，这是个明显的解决方案，但要当心我们修复后出现的Bug。
</p>

<div class="english">
<pre>
func Serve(queue chan *Request) {
	for req := range queue {
		&lt;-sem
		go func() {
			process(req) // Buggy; see explanation below.
			sem &lt;- 1
		}()
	}
}</pre>
</div>

<pre>
func Serve(queue chan *Request) {
	for req := range queue {
		&lt;-sem
		go func() {
			process(req) // 这儿有Bug，解释见下。
			sem &lt;- 1
		}()
	}
}</pre>

<div class="english">
<p>
The bug is that in a Go <code>for</code> loop, the loop variable
is reused for each iteration, so the <code>req</code>
variable is shared across all goroutines.
That's not what we want.
We need to make sure that <code>req</code> is unique for each goroutine.
Here's one way to do that, passing the value of <code>req</code> as an argument
to the closure in the goroutine:
</p>
</div>

<p>
Bug出现在Go的 <code>for</code> 循环中，该循环变量在每次迭代时会被重用，因此
<code>req</code> 变量会在所有的Go程间共享，这不是我们想要的。我们需要确保
<code>req</code> 对于每个Go程来说都是唯一的。有一种方法能够做到，就是将
<code>req</code> 的值作为实参传入到该Go程的闭包中：
</p>

<pre>
func Serve(queue chan *Request) {
	for req := range queue {
		&lt;-sem
		go func(req *Request) {
			process(req)
			sem &lt;- 1
		}(req)
	}
}</pre>

<div class="english">
<p>
Compare this version with the previous to see the difference in how
the closure is declared and run.
Another solution is just to create a new variable with the same
name, as in this example:
</p>
</div>

<p>
比较前后两个版本，观察该闭包声明和运行中的差别。
另一种解决方案就是以相同的名字创建新的变量，如例中所示：
</p>

<div class="english">
<pre>
func Serve(queue chan *Request) {
	for req := range queue {
		&lt;-sem
		req := req // Create new instance of req for the goroutine.
		go func() {
			process(req)
			sem &lt;- 1
		}()
	}
}</pre>
</div>

<pre>
func Serve(queue chan *Request) {
	for req := range queue {
		&lt;-sem
		req := req // 为该Go程创建 req 的新实例。
		go func() {
			process(req)
			sem &lt;- 1
		}()
	}
}
</pre>

<div class="english">
<p>
It may seem odd to write
</p>
</div>

<p>
它的写法看起来有点奇怪
</p>

<pre>
req := req
</pre>

<div class="english">
<p>
but it's a legal and idiomatic in Go to do this.
You get a fresh version of the variable with the same name, deliberately
shadowing the loop variable locally but unique to each goroutine.
</p>
</div>

<p>
但在Go中这样做是合法且惯用的。你用相同的名字获得了该变量的一个新的版本，
以此来局部地刻意屏蔽循环变量，使它对每个Go程保持唯一。
</p>

<div class="english">
<p>
Going back to the general problem of writing the server,
another approach that manages resources well is to start a fixed
number of <code>handle</code> goroutines all reading from the request
channel.
The number of goroutines limits the number of simultaneous
calls to <code>process</code>.
This <code>Serve</code> function also accepts a channel on which
it will be told to exit; after launching the goroutines it blocks
receiving from that channel.
</p>
</div>

<p>
回到编写服务器的一般问题上来。另一种管理资源的好方法就是启动固定数量的
<code>handle</code> Go程，一起从请求信道中读取数据。Go程的数量限制了同时调用
<code>process</code> 的数量。<code>Serve</code> 同样会接收一个通知退出的信道，
在启动所有Go程后，它将阻塞并暂停从信道中接收消息。
</p>

<div class="english">
<pre>
func handle(queue chan *Request) {
	for r := range queue {
		process(r)
	}
}

func Serve(clientRequests chan *Request, quit chan bool) {
	// Start handlers
	for i := 0; i &lt; MaxOutstanding; i++ {
		go handle(clientRequests)
	}
	&lt;-quit  // Wait to be told to exit.
}
</pre>
</div>

<pre>
func handle(queue chan *Request) {
	for r := range queue {
		process(r)
	}
}

func Serve(clientRequests chan *Request, quit chan bool) {
	// 启动处理程序
	for i := 0; i &lt; MaxOutstanding; i++ {
		go handle(clientRequests)
	}
	&lt;-quit  // 等待通知退出。
}
</pre>

<div class="english">
<h3 id="chan_of_chan">Channels of channels</h3>
</div>

<h3 id="信道中的信道">信道中的信道</h3>

<div class="english">
<p>
One of the most important properties of Go is that
a channel is a first-class value that can be allocated and passed
around like any other.  A common use of this property is
to implement safe, parallel demultiplexing.
</p>
</div>

<p>
Go最重要的特性就是信道是一等值，它可以被分配并像其它值到处传递。
这种特性通常被用来实现安全、并行的多路分解。
</p>

<div class="english">
<p>
In the example in the previous section, <code>handle</code> was
an idealized handler for a request but we didn't define the
type it was handling.  If that type includes a channel on which
to reply, each client can provide its own path for the answer.
Here's a schematic definition of type <code>Request</code>.
</p>
</div>

<p>
在上一节的例子中，<code>handle</code> 是个非常理想化的请求处理程序，
但我们并未定义它所处理的请求类型。若该类型包含一个可用于回复的信道，
那么每一个客户端都能为其回应提供自己的路径。以下为 <code>Request</code>
类型的大概定义。
</p>

<pre>
type Request struct {
	args        []int
	f           func([]int) int
	resultChan  chan int
}
</pre>

<div class="english">
<p>
The client provides a function and its arguments, as well as
a channel inside the request object on which to receive the answer.
</p>
</div>

<p>
客户端提供了一个函数及其实参，此外在请求对象中还有个接收应答的信道。
</p>

<div class="english">
<pre>
func sum(a []int) (s int) {
	for _, v := range a {
		s += v
	}
	return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>
</div>

<pre>
func sum(a []int) (s int) {
	for _, v := range a {
		s += v
	}
	return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// 发送请求
clientRequests &lt;- request
// 等待回应
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>

<p>
On the server side, the handler function is the only thing that changes.
</p>
<pre>
func handle(queue chan *Request) {
	for req := range queue {
		req.resultChan &lt;- req.f(req.args)
	}
}
</pre>

<div class="english">
<p>
There's clearly a lot more to do to make it realistic, but this
code is a framework for a rate-limited, parallel, non-blocking RPC
system, and there's not a mutex in sight.
</p>
</div>

<p>
要使其实际可用还有很多工作要做，这些代码仅能实现一个速率有限、并行、非阻塞RPC系统的
框架，而且它并不包含互斥锁。
</p>

<div class="english">
<h3 id="parallel">Parallelization</h3>
</div>

<h3 id="并行">并行化</h3>

<div class="english">
<p>
Another application of these ideas is to parallelize a calculation
across multiple CPU cores.  If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.
</p>
</div>

<p>
这些设计的另一个应用是在多CPU核心上实现并行计算。如果计算过程能够被分为几块
可独立执行的过程，它就可以在每块计算结束时向信道发送信号，从而实现并行处理。
</p>

<div class="english">
<p>
Let's say we have an expensive operation to perform on a vector of items,
and that the value of the operation on each item is independent,
as in this idealized example.
</p>
</div>

<p>
让我们看看这个理想化的例子。我们在对一系列向量项进行极耗资源的操作，
而每个项的值计算是完全独立的。
</p>

<div class="english">
<pre>
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
	for ; i &lt; n; i++ {
		v[i] += u.Op(v[i])
	}
	c &lt;- 1    // signal that this piece is done
}
</pre>
</div>

<pre>
type Vector []float64

// 将此操应用至 v[i], v[i+1] ... 直到 v[n-1]
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
	for ; i &lt; n; i++ {
		v[i] += u.Op(v[i])
	}
	c &lt;- 1    // 发信号表示这一块计算完成。
}
</pre>

<div class="english">
<p>
We launch the pieces independently in a loop, one per CPU.
They can complete in any order but it doesn't matter; we just
count the completion signals by draining the channel after
launching all the goroutines.
</p>
</div>

<p>
我们在循环中启动了独立的处理块，每个CPU将执行一个处理。
它们有可能以乱序的形式完成并结束，但这没有关系；
我们只需在所有Go程开始后接收，并统计信道中的完成信号即可。
</p>

<div class="english">
<pre>
const NCPU = 4  // number of CPU cores

func (v Vector) DoAll(u Vector) {
	c := make(chan int, NCPU)  // Buffering optional but sensible.
	for i := 0; i &lt; NCPU; i++ {
		go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
	}
	// Drain the channel.
	for i := 0; i &lt; NCPU; i++ {
		&lt;-c    // wait for one task to complete
	}
	// All done.
}
</pre>
</div>

<pre>
const NCPU = 4  // CPU核心数

func (v Vector) DoAll(u Vector) {
	c := make(chan int, NCPU)  // 缓冲区是可选的，但明显用上更好
	for i := 0; i &lt; NCPU; i++ {
		go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
	}
	// 排空信道。
	for i := 0; i &lt; NCPU; i++ {
		&lt;-c    // 等待任务完成
	}
	// 一切完成。
}
</pre>

<div class="english">
<p>
The current implementation of the Go runtime
will not parallelize this code by default.
It dedicates only a single core to user-level processing.  An
arbitrary number of goroutines can be blocked in system calls, but
by default only one can be executing user-level code at any time.
It should be smarter and one day it will be smarter, but until it
is if you want CPU parallelism you must tell the run-time
how many goroutines you want executing code simultaneously.  There
are two related ways to do this.  Either run your job with environment
variable <code>GOMAXPROCS</code> set to the number of cores to use
or import the <code>runtime</code> package and call
<code>runtime.GOMAXPROCS(NCPU)</code>.
A helpful value might be <code>runtime.NumCPU()</code>, which reports the number
of logical CPUs on the local machine.
Again, this requirement is expected to be retired as the scheduling and run-time improve.
</p>
</div>

<p>
目前Go运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。
任意数量的Go程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。
它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望CPU并行执行，
就必须告诉运行时你希望同时有多少Go程能执行代码。有两种途径可意识形态，要么
在运行你的工作时将 <code>GOMAXPROCS</code> 环境变量设为你要使用的核心数，
要么导入 <code>runtime</code> 包并调用 <code>runtime.GOMAXPROCS(NCPU)</code>。
<code>runtime.NumCPU()</code> 的值可能很有用，它会返回当前机器的逻辑CPU核心数。
当然，随着调度算法和运行时的改进，将来会不再需要这种方法。
</p>

<div class="english">
<p>
Be sure not to confuse the ideas of concurrency—structuring a program
as independently executing components—and parallelism—executing
calculations in parallel for efficiency on multiple CPUs.
Although the concurrency features of Go can make some problems easy
to structure as parallel computations, Go is a concurrent language,
not a parallel one, and not all parallelization problems fit Go's model.
For a discussion of the distinction, see the talk cited in
<a href="http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html">this
blog post</a>.
</p>
</div>

<p>
注意不要混淆并发和并行的概念：并发是用可独立执行的组件构造程序的方法，
而并行则是为了效率在多CPU上平行地进行计算。尽管Go的并发特性能够让某些问题更易构造成并行计算，
但Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题。
关于其中区别的讨论，见
<a href="http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html">此博文</a>。
</p>

<div class="english">
<h3 id="leaky_buffer">A leaky buffer</h3>
</div>

<h3 id="泄露缓冲">可能泄露的缓冲区</h3>

<div class="english">
<p>
The tools of concurrent programming can even make non-concurrent
ideas easier to express.  Here's an example abstracted from an RPC
package.  The client goroutine loops receiving data from some source,
perhaps a network.  To avoid allocating and freeing buffers, it keeps
a free list, and uses a buffered channel to represent it.  If the
channel is empty, a new buffer gets allocated.
Once the message buffer is ready, it's sent to the server on
<code>serverChan</code>.
</p>
</div>

<p>
并发编程的工具甚至能很容易地表达非并发的思想。这里有个提取自RPC包的例子。
客户端Go程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区，
它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。
一旦消息缓冲区就绪，它将通过 <code>serverChan</code> 被发送到服务器。
<code>serverChan</code>.
</p>

<div class="english">
<pre>
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
	for {
		var b *Buffer
		// Grab a buffer if available; allocate if not.
		select {
		case b = &lt;-freeList:
			// Got one; nothing more to do.
		default:
			// None free, so allocate a new one.
			b = new(Buffer)
		}
		load(b)              // Read next message from the net.
		serverChan &lt;- b      // Send to server.
	}
}
</pre>
</div>

<pre>
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
	for {
		var b *Buffer
		// 若缓冲区可用就用它，不可用就分配个新的。
		select {
		case b = &lt;-freeList:
			// 获取一个，不做别的。
		default:
			// 非空闲，因此分配一个新的。
			b = new(Buffer)
		}
		load(b)              // 从网络中读取下一条消息。
		serverChan &lt;- b   // 发送至服务器。
	}
}
</pre>

<div class="english">
<p>
The server loop receives each message from the client, processes it,
and returns the buffer to the free list.
</p>
</div>

<p>
服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。
</p>

<div class="english">
<pre>
func server() {
	for {
		b := &lt;-serverChan    // Wait for work.
		process(b)
		// Reuse buffer if there's room.
		select {
		case freeList &lt;- b:
			// Buffer on free list; nothing more to do.
		default:
			// Free list full, just carry on.
		}
	}
}
</pre>
</div>

<pre>
func server() {
	for {
		b := &lt;-serverChan    // 等待工作。
		process(b)
		// 若缓冲区有空间就重用它。
		select {
		case freeList &lt;- b:
			// 将缓冲区放大空闲列表中，不做别的。
		default:
			// 空闲列表已满，保持就好。
		}
	}
}
</pre>

<div class="english">
<p>
The client attempts to retrieve a buffer from <code>freeList</code>;
if none is available, it allocates a fresh one.
The server's send to <code>freeList</code> puts <code>b</code> back
on the free list unless the list is full, in which case the
buffer is dropped on the floor to be reclaimed by
the garbage collector.
(The <code>default</code> clauses in the <code>select</code>
statements execute when no other case is ready,
meaning that the <code>selects</code> never block.)
This implementation builds a leaky bucket free list
in just a few lines, relying on the buffered channel and
the garbage collector for bookkeeping.
</p>
</div>

<p>
客户端试图从 <code>freeList</code> 中获取缓冲区；若没有缓冲区可用，
它就将分配一个新的。服务器将 <code>b</code> 放回空闲列表 <code>freeList</code>
中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。（<code>select</code>
语句中的 <code>default</code> 子句在没有条件符合时执行，这也就意味着
<code>selects</code> 永远不会被阻塞。）依靠带缓冲的信道和垃圾回收器的记录，
我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。
</p>

<div class="english">
<h2 id="errors">Errors</h2>
</div>

<h2 id="错误">错误</h2>

<div class="english">
<p>
Library routines must often return some sort of error indication to
the caller.  As mentioned earlier, Go's multivalue return makes it
easy to return a detailed error description alongside the normal
return value.  By convention, errors have type <code>error</code>,
a simple built-in interface.
</p>
</div>

<p>
库例程通常需要向调用者返回某种类型的错误提示。之前提到过，Go语言的多值返回特性，
使得它在返回常规的值时，还能轻松地返回详细的错误描述。按照约定，错误的类型通常为
<code>error</code>，这是一个内建的简单接口。
</p>

<pre>
type error interface {
	Error() string
}
</pre>

<div class="english">
<p>
A library writer is free to implement this interface with a
richer model under the covers, making it possible not only
to see the error but also to provide some context.
For example, <code>os.Open</code> returns an <code>os.PathError</code>.
</p>
</div>

<p>
库的编写者通过更丰富的底层模型可以轻松实现这个接口，这样不仅能看见错误，
还能提供一些上下文。例如，<code>os.Open</code> 可返回一个 <code>os.PathError</code>。
</p>

<div class="english">
<pre>
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
	Op string    // "open", "unlink", etc.
	Path string  // The associated file.
	Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
	return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>
</div>

<pre>
// PathError 记录一个错误以及产生该错误的路径和操作。
type PathError struct {
	Op string    // "open"、"unlink" 等等。
	Path string  // 相关联的文件。
	Err error    // 由系统调用返回。
}

func (e *PathError) Error() string {
	return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>

<div class="english">
<p>
<code>PathError</code>'s <code>Error</code> generates
a string like this:
</p>
</div>

<p>
<code>PathError</code>的 <code>Error</code> 会生成如下错误信息：
</p>

<pre>
open /etc/passwx: no such file or directory
</pre>

<div class="english">
<p>
Such an error, which includes the problematic file name, the
operation, and the operating system error it triggered, is useful even
if printed far from the call that caused it;
it is much more informative than the plain
"no such file or directory".
</p>
</div>

<p>
这种错误包含了出错的文件名、操作和触发的操作系统错误，即便在产生该错误的调用
和输出的错误信息相距甚远时，它也会非常有用，这比苍白的“不存在该文件或目录”更具说明性。
</p>

<div class="english">
<p>
When feasible, error strings should identify their origin, such as by having
a prefix naming the operation or package that generated the error.  For example, in package
<code>image</code>, the string representation for a decoding error due to an
unknown format is "image: unknown format".
</p>
</div>

<p>
错误字符串应尽可能地指明它们的来源，例如产生该错误的包名前缀。例如在
<code>image</code> 包中，由于未知格式导致解码错误的字符串为“image: unknown format”。
</p>

<div class="english">
<p>
Callers that care about the precise error details can
use a type switch or a type assertion to look for specific
errors and extract details.  For <code>PathErrors</code>
this might include examining the internal <code>Err</code>
field for recoverable failures.
</p>
</div>

<p>
若调用者关心错误的完整细节，可使用类型选择或者类型断言来查看特定错误，并抽取其细节。
对于 <code>PathErrors</code>，它应该还包含检查内部的 <code>Err</code>
字段以进行可能的错误恢复。
</p>

<div class="english">
<pre>
for try := 0; try &lt; 2; try++ {
	file, err = os.Create(filename)
	if err == nil {
		return
	}
	if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
		deleteTempFiles()  // Recover some space.
		continue
	}
	return
}
</pre>
</div>

<pre>
for try := 0; try &lt; 2; try++ {
	file, err = os.Create(filename)
	if err == nil {
		return
	}
	if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
		deleteTempFiles()  // 恢复一些空间。
		continue
	}
	return
}
</pre>

<div class="english">
<p>
The second <code>if</code> statement here is another <a href="#interface_conversions">type assertion</a>.
If it fails, <code>ok</code> will be false, and <code>e</code>
will be <code>nil</code>.
If it succeeds,  <code>ok</code> will be true, which means the
error was of type <code>*os.PathError</code>, and then so is <code>e</code>,
which we can examine for more information about the error.
</p>
</div>

<p>
这里的第二条 <code>if</code> 是另一种<a href="#接口转换">类型断言</a>。若它失败，
<code>ok</code> 将为 <code>false</code>，而 <code>e</code> 则为<code>nil</code>.
若它成功，<code>ok</code> 将为 <code>true</code>，这意味着该错误属于
<code>*os.PathError</code> 类型，而 <code>e</code> 能够检测关于该错误的更多信息。
</p>

<div class="english">
<h3 id="panic">Panic</h3>
</div>

<h3 id="panic">Panic</h3>

<div class="english">
<p>
The usual way to report an error to a caller is to return an
<code>error</code> as an extra return value.  The canonical
<code>Read</code> method is a well-known instance; it returns a byte
count and an <code>error</code>.  But what if the error is
unrecoverable?  Sometimes the program simply cannot continue.
</p>
</div>

<p>
向调用者报告错误的一般方式就是将 <code>error</code> 作为额外的值返回。
标准的 <code>Read</code> 方法就是个众所周知的实例，它返回一个字节计数和一个
<code>error</code>。但如果错误时不可恢复的呢？有时程序就是不能继续运行。
</p>

<div class="english">
<p>
For this purpose, there is a built-in function <code>panic</code>
that in effect creates a run-time error that will stop the program
(but see the next section).  The function takes a single argument
of arbitrary type&mdash;often a string&mdash;to be printed as the
program dies.  It's also a way to indicate that something impossible has
happened, such as exiting an infinite loop.
</p>
</div>

<p>
为此，我们提供了内建的 <code>panic</code> 函数，它会产生一个运行时错误并终止程序
（但请继续看下一节）。该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印。
它还能表明发生了意料之外的事情，比如从无限循环中退出了。
</p>

<div class="english">
<pre>
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
	z := x/3   // Arbitrary initial value
	for i := 0; i &lt; 1e6; i++ {
		prevz := z
		z -= (z*z*z-x) / (3*z*z)
		if veryClose(z, prevz) {
			return z
		}
	}
	// A million iterations has not converged; something is wrong.
	panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>
</div>

<pre>
// 用牛顿法计算立方根的一个玩具实现。
func CubeRoot(x float64) float64 {
	z := x/3   // 任意初始值
	for i := 0; i &lt; 1e6; i++ {
		prevz := z
		z -= (z*z*z-x) / (3*z*z)
		if veryClose(z, prevz) {
			return z
		}
	}
	// 一百万次迭代并未收敛，事情出错了。
	panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>

<div class="english">
<p>
This is only an example but real library functions should
avoid <code>panic</code>.  If the problem can be masked or worked
around, it's always better to let things continue to run rather
than taking down the whole program.  One possible counterexample
is during initialization: if the library truly cannot set itself up,
it might be reasonable to panic, so to speak.
</p>
</div>

<p>
这仅仅是个示例，实际的库函数应避免 <code>panic</code>。若问题可以被屏蔽或解决，
最好就是让程序继续运行而不是终止整个程序。一个可能的反例就是初始化：
若某个库真的不能让自己工作，且有足够理由产生Panic，那就由它去吧。
</p>

<pre>
var user = os.Getenv("USER")

func init() {
	if user == "" {
		panic("no value for $USER")
	}
}
</pre>

<div class="english">
<h3 id="recover">Recover</h3>
</div>

<h3 id="恢复">恢复</h3>

<div class="english">
<p>
When <code>panic</code> is called, including implicitly for run-time
errors such as indexing a slice out of bounds or failing a type
assertion, it immediately stops execution of the current function
and begins unwinding the stack of the goroutine, running any deferred
functions along the way.  If that unwinding reaches the top of the
goroutine's stack, the program dies.  However, it is possible to
use the built-in function <code>recover</code> to regain control
of the goroutine and resume normal execution.
</p>
</div>

<p>
当 <code>panic</code> 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败），
程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟的函数。
若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 <code>recover</code>
函数来重新或来取回Go程的控制权限并使其恢复正常执行。
</p>

<div class="english">
<p>
A call to <code>recover</code> stops the unwinding and returns the
argument passed to <code>panic</code>.  Because the only code that
runs while unwinding is inside deferred functions, <code>recover</code>
is only useful inside deferred functions.
</p>
</div>

<p>
调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。
由于在回溯时只有被推迟函数中的代码在运行，因此 <code>recover</code>
只能在被推迟的函数中才有效。
</p>

<div class="english">
<p>
One application of <code>recover</code> is to shut down a failing goroutine
inside a server without killing the other executing goroutines.
</p>
</div>

<p>
<code>recover</code> 的一个应用就是在服务器中终止失败的Go程而无需杀死其它正在执行的Go程。
</p>

<pre>
func server(workChan &lt;-chan *Work) {
	for work := range workChan {
		go safelyDo(work)
	}
}

func safelyDo(work *Work) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("work failed:", err)
		}
	}()
	do(work)
}
</pre>

<div class="english">
<p>
In this example, if <code>do(work)</code> panics, the result will be
logged and the goroutine will exit cleanly without disturbing the
others.  There's no need to do anything else in the deferred closure;
calling <code>recover</code> handles the condition completely.
</p>
</div>

<p>
在此例中，若 <code>do(work)</code> 触发了Panic，其结果就会被记录，
而该Go程会被干净利落地结束，不会干扰到其它Go程。我们无需在推迟的闭包中做任何事情，
<code>recover</code> 会处理好这一切。
</p>

<div class="english">
<p>
Because <code>recover</code> always returns <code>nil</code> unless called directly
from a deferred function, deferred code can call library routines that themselves
use <code>panic</code> and <code>recover</code> without failing.  As an example,
the deferred function in <code>safelyDo</code> might call a logging function before
calling <code>recover</code>, and that logging code would run unaffected
by the panicking state.
</p>
</div>

<p>
由于直接从被推迟函数中调用 <code>recover</code> 时不会返回 <code>nil</code>，
因此被推迟的代码能够调用本身使用了 <code>panic</code> 和 <code>recover</code>
的库函数而不会失败。例如在 <code>safelyDo</code> 中，被推迟的函数可能在调用
<code>recover</code> 前先调用记录函数，而该记录函数应当不受Panic状态的代码的影响。
</p>

<div class="english">
<p>
With our recovery pattern in place, the <code>do</code>
function (and anything it calls) can get out of any bad situation
cleanly by calling <code>panic</code>.  We can use that idea to
simplify error handling in complex software.  Let's look at an
idealized version of a <code>regexp</code> package, which reports
parsing errors by calling <code>panic</code> with a local
error type.  Here's the definition of <code>Error</code>,
an <code>error</code> method, and the <code>Compile</code> function.
</p>
</div>

<p>
通过恰当地使用恢复模式，<code>do</code> 函数（及其调用的任何代码）可通过调用
<code>panic</code> 来避免更坏的结果。我们可以利用这种思想来简化复杂软件中的错误处理。
让我们看看 <code>regexp</code> 包的理想化版本，它会以局部的错误类型调用 <code>panic</code>
来报告解析错误。以下是一个 <code>error</code> 类型的 <code>Error</code> 方法和一个
<code>Compile</code> 函数的定义：
</p>

<div class="english">
<pre>
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
	return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
	panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
	regexp = new(Regexp)
	// doParse will panic if there is a parse error.
	defer func() {
		if e := recover(); e != nil {
			regexp = nil    // Clear return value.
			err = e.(Error) // Will re-panic if not a parse error.
		}
	}()
	return regexp.doParse(str), nil
}
</pre>
</div>

<pre>
// Error 是解析错误的类型，它满足 error 接口。
type Error string
func (e Error) Error() string {
	return string(e)
}

// error 是 *Regexp 的方法，它通过用一个 Error 触发Panic来报告解析错误。
func (regexp *Regexp) error(err string) {
	panic(Error(err))
}

// Compile 返回该正则表达式解析后的表示。
func Compile(str string) (regexp *Regexp, err error) {
	regexp = new(Regexp)
	// doParse will panic if there is a parse error.
	defer func() {
		if e := recover(); e != nil {
			regexp = nil    // 清理返回值。
			err = e.(Error) // 若它不是解析错误，将重新触发Panic。
		}
	}()
	return regexp.doParse(str), nil
}
</pre>

<div class="english">
<p>
If <code>doParse</code> panics, the recovery block will set the
return value to <code>nil</code>&mdash;deferred functions can modify
named return values.  It will then check, in the assignment
to <code>err</code>, that the problem was a parse error by asserting
that it has the local type <code>Error</code>.
If it does not, the type assertion will fail, causing a run-time error
that continues the stack unwinding as though nothing had interrupted
it.
This check means that if something unexpected happens, such
as an index out of bounds, the code will fail even though we
are using <code>panic</code> and <code>recover</code> to handle
parse errors.
</p>
</div>

<p>
若 <code>doParse</code> 触发了Panic，恢复块会将返回值设为 <code>nil</code>
—被推迟的函数能够修改已命名的返回值。在 <code>err</code> 的赋值过程中，
我们将通过断言它是否拥有局部类型 <code>Error</code> 来检查它。若它没有，
类型断言将会失败，此时会产生运行时错误，并继续栈的回溯，仿佛一切从未中断过一样。
该检查意味着若发生了一些像索引越界之类的意外，那么即便我们使用了 <code>panic</code>
和 <code>recover</code> 来处理解析错误，代码仍然会失败。
</p>

<div class="english">
<p>
With error handling in place, the <code>error</code> method (because it's a
method bound to a type, it's fine, even natural, for it to have the same name
as the builtin <code>error</code> type)
makes it easy to report parse errors without worrying about unwinding
the parse stack by hand:
</p>
</div>

<p>
通过适当的错误处理，<code>error</code> 方法（由于它是个绑定到具体类型的方法，
因此即便它与内建的 <code>error</code> 类型名字相同也没有关系）
能让报告解析错误变得更容易，而无需手动处理回溯的解析栈：
</p>

<pre>
if pos == 0 {
	re.error("'*' illegal at start of expression")
}
</pre>

<div class="english">
<p>
Useful though this pattern is, it should be used only within a package.
<code>Parse</code> turns its internal <code>panic</code> calls into
<code>error</code> values; it does not expose <code>panics</code>
to its client.  That is a good rule to follow.
</p>
</div>

<p>
尽管这种模式很有用，但它应当仅在包内使用。<code>Parse</code> 会将其内部的
<code>panic</code> 调用转为 <code>error</code> 值，它并不会向调用者暴露出
<code>panic</code>。这是个值得遵守的良好规则。
</p>

<div class="english">
<p>
By the way, this re-panic idiom changes the panic value if an actual
error occurs.  However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible.  Thus this simple re-panic approach is usually
sufficient&mdash;it's a crash after all&mdash;but if you want to
display only the original value, you can write a little more code to
filter unexpected problems and re-panic with the original error.
That's left as an exercise for the reader.
</p>
</div>

<p>
顺便一提，这种重新触发Panic的惯用法会在产生实际错误时改变Panic的值。
然而，不管是原始的还是新的错误都会在崩溃报告中显示，因此问题的根源仍然是可见的。
这种简单的重新触发Panic的模型已经够用了，毕竟他只是一次崩溃。
但若你只想显示原始的值，也可以多写一点代码来过滤掉不需要的问题，然后用原始值再次触发Panic。
这里就将这个练习留给读者了。
</p>


<div class="english">
<h2 id="web_server">A web server</h2>
</div>

<h2 id="Web服务器">一个Web服务器</h2>

<div class="english">
<p>
Let's finish with a complete Go program, a web server.
This one is actually a kind of web re-server.
Google provides a service at
<a href="http://chart.apis.google.com">http://chart.apis.google.com</a>
that does automatic formatting of data into charts and graphs.
It's hard to use interactively, though,
because you need to put the data into the URL as a query.
The program here provides a nicer interface to one form of data: given a short piece of text,
it calls on the chart server to produce a QR code, a matrix of boxes that encode the
text.
That image can be grabbed with your cell phone's camera and interpreted as,
for instance, a URL, saving you typing the URL into the phone's tiny keyboard.
</p>
</div>

<p>
让我们以一个完整的Go程序作为结束吧，一个Web服务器。该程序其实只是个Web服务器的重用。
Google在<a href="http://chart.apis.google.com">http://chart.apis.google.com</a>
上提供了一个将表单数据自动转换为图表的服务。不过，该服务很难交互，
因为你需要将数据作为查询放到URL中。此程序为一种数据格式提供了更好的的接口：
给定一小段文本，它将调用图表服务器来生成二维码（QR码），这是一种编码文本的点格矩阵。
该图像可被你的手机摄像头捕获，并解释为一个字符串，比如URL，
这样就免去了你在狭小的手机键盘上键入URL的麻烦。
</p>

<div class="english">
<p>
Here's the complete program.
An explanation follows.
</p>
</div>

<p>
以下为完整的程序，随后有一段解释。
</p>

{{code "/doc/progs/eff_qr.go" `/package/` `$`}}

<div class="english">
<p>
The pieces up to <code>main</code> should be easy to follow.
The one flag sets a default HTTP port for our server.  The template
variable <code>templ</code> is where the fun happens. It builds an HTML template
that will be executed by the server to display the page; more about
that in a moment.
</p>
</div>

<p>
<code>main</code> 之前的代码应该比较容易理解。我们通过一个标志为服务器设置了默认端口。
模板变量  <code>templ</code> 正式有趣的地方。它构建的HTML模版将会被服务器执行并显示在页面中。
稍后我们将详细讨论。
</p>

<div class="english">
<p>
The <code>main</code> function parses the flags and, using the mechanism
we talked about above, binds the function <code>QR</code> to the root path
for the server.  Then <code>http.ListenAndServe</code> is called to start the
server; it blocks while the server runs.
</p>
</div>

<p>
<code>main</code> 函数解析了参数标志并使用我们讨论过的机制将 <code>QR</code>
函数绑定到服务器的根路径。然后调用 <code>http.ListenAndServe</code>
启动服务器；它将在服务器运行时处于阻塞状态。
</p>

<div class="english">
<p>
<code>QR</code> just receives the request, which contains form data, and
executes the template on the data in the form value named <code>s</code>.
</p>
</div>

<p>
<code>QR</code> 仅接受包含表单数据的请求，并为表单值 <code>s</code> 中的数据执行模板。
</p>

<div class="english">
<p>
The template package <code>html/template</code> is powerful;
this program just touches on its capabilities.
In essence, it rewrites a piece of HTML text on the fly by substituting elements derived
from data items passed to <code>templ.Execute</code>, in this case the
form value.
Within the template text (<code>templateStr</code>),
double-brace-delimited pieces denote template actions.
The piece from <code>{{html "{{if .}}"}}</code>
to <code>{{html "{{end}}"}}</code> executes only if the value of the current data item, called <code>.</code> (dot),
is non-empty.
That is, when the string is empty, this piece of the template is suppressed.
</p>
</div>

<p>
模板包 <code>html/template</code> 非常强大；该程序只是浅尝辄止。
本质上，它通过在运行时将数据项中提取的元素（在这里是表单值）传给
<code>templ.Execute</code> 执行因而重写了HTML文本。
在模板文本（<code>templateStr</code>）中，双大括号界定的文本表示模板的动作。
从 <code>{{html "{{if .}}"}}</code> 到 <code>{{html "{{end}}"}}</code>
的代码段仅在当前数据项（这里是点 <code>.</code>）的值非空时才会执行。
也就是说，当字符串为空时，此部分模板段会被忽略。
</p>

<div class="english">
<p>
The two snippets <code>{{html "{{.}}"}}</code> say to show the data presented to
the template—the query string—on the web page.
The HTML template package automatically provides appropriate escaping so the
text is safe to display.
</p>
</div>

<p>
其中两段 <code>{{html "{{.}}"}}</code> 表示要将数据显示在模板中
（即将查询字符串显示在Web页面上）。HTML模板包将自动对文本进行转义，
因此文本的显示是安全的。
</p>

<div class="english">
<p>
The rest of the template string is just the HTML to show when the page loads.
If this is too quick an explanation, see the <a href="/pkg/html/template/">documentation</a>
for the template package for a more thorough discussion.
</p>
</div>

<p>
余下的模板字符串只是页面加载时将要显示的HTML。如果这段解释你无法理解，请参考
<a href="/pkg/html/template/">文档</a> 获得更多有关模板包的解释。
</p>

<div class="english">
<p>
And there you have it: a useful web server in a few lines of code plus some
data-driven HTML text.
Go is powerful enough to make a lot happen in a few lines.
</p>
</div>

<p>
你终于如愿以偿了：以几行代码实现的，包含一些数据驱动的HTML文本的Web服务器。
Go语言强大到能让很多事情以短小精悍的方式解决。
</p>

<!--
TODO
<pre>
verifying implementation
type Color uint32

// Check that Color implements image.Color and image.Image
var _ image.Color = Black
var _ image.Image = Black
</pre>
-->

