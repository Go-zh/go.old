<!--{
	"Title": "使用GDB调试Go代码",
	"Path": "/doc/gdb"
}-->

<!--{
	"Title": "Debugging Go Code with GDB",
	"Path": "/doc/gdb"
}-->

<div class="english">
<p><i>
This applies to the <code>gc</code> toolchain. Gccgo has native gdb support.
Besides this overview you might want to consult the
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">GDB manual</a>.
</i></p>
</div>

<p><i>
本文档适用于 <code>gc</code> 工具链。Gccgo 拥有 gdb 的原生支持。
除此概览外，你或许还想查阅<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">GDB 手册</a>。
</i></p>

<div class="english">
<p>
GDB does not understand Go programs well.
The stack management, threading, and runtime contain aspects that differ
enough from the execution model GDB expects that they can confuse
the debugger, even when the program is compiled with gccgo.
As a consequence, although GDB can be useful in some situations, it is
not a reliable debugger for Go programs, particularly heavily concurrent ones.
Moreover, it is not a priority for the Go project to address these issues, which
are difficult.
In short, the instructions below should be taken only as a guide to how
to use GDB when it works, not as a guarantee of success.
</p>
</div>

<p>
GDB 无法很好地理解 Go 程序。堆栈管理、线程和运行时包含的方面与 GDB 预期的执行模型非常不同，
即便程序是由 gccgo 编译的，它们也会把调试器搞乱。作为一个推论，即便 GDB 在某些情况下很有用，
但对于 Go 程序来说它并不是个可靠的调试器，对大并发来说更是如此。此外，它并不是 Go
项目需要优先解决的问题，这是很难的。简言之，就是以下指令仅在 GDB 可用时才能作为指导被采纳，
而并不保证成功。
</p>

<div class="english">
<p>
In time, a more Go-centric debugging architecture may be required.
</p>
</div>

<p>
到时候，我们会需要一个更加以 Go 为中心的调试架构。
</p>

<div class="english">
<h2 id="Introduction">Introduction</h2>
</div>

<h2 id="引言">引言</h2>

<div class="english">
<p>
When you compile and link your Go programs with the <code>gc</code> toolchain
on Linux, Mac OS X, FreeBSD or NetBSD, the resulting binaries contain DWARFv3
debugging information that recent versions (&gt;7.1) of the GDB debugger can
use to inspect a live process or a core dump.
</p>
</div>

<p>
当你使用 <code>gc</code> 工具链在 Linux、Mac OS X、FreeBSD 或 NetBSD 上编译或链接 Go 程序时，
所产生的二进制文件会包含 DWARFv3 调试信息，最近版本（&gt;7.1）的
GDB 调试器可用于检查实时进程或核心转储。
</p>

<div class="english">
<p>
Pass the <code>'-w'</code> flag to the linker to omit the debug information
(for example, <code>go build -ldflags "-w" prog.go</code>).
</p>
</div>

<p>
可通过向连接器传递 <code>'-w'</code> 标记来省略调试信息
（例如，<code>go build -ldflags "-w" prog.go</code>）。
</p>

<div class="english">
<p>
The code generated by the <code>gc</code> compiler includes inlining of
function invocations and registerization of variables. These optimizations
can sometimes make debugging with <code>gdb</code> harder. To disable them
when debugging, pass the flags <code>-gcflags "-N -l"</code> to the
<a href="/cmd/go"><code>go</code></a> command used to build the code being
debugged.
</p>
</div>

<p>
由 <code>gc</code> 编译器生成的代码包含内联函数调用和注册变量。这些优化有时会让
<code>GDB</code> 调试变得更难。要在调试时关闭它们，请向用于构建代码进行调试的
<a href="/cmd/go"><code>go</code></a> 命令传递 <code>-gcflags "-N -l"</code> 标记。
</p>


<div class="english">
<h3 id="Common_Operations">Common Operations</h3>
</div>

<h3 id="一般操作">一般操作</h3>

<div class="english">
<ul>
<li>
Show file and line number for code, set breakpoints and disassemble:
<pre>(gdb) <b>list</b>
(gdb) <b>list <i>line</i></b>
(gdb) <b>list <i>file.go</i>:<i>line</i></b>
(gdb) <b>break <i>line</i></b>
(gdb) <b>break <i>file.go</i>:<i>line</i></b>
(gdb) <b>disas</b></pre>
</li>
<li>
Show backtraces and unwind stack frames:
<pre>(gdb) <b>bt</b>
(gdb) <b>frame <i>n</i></b></pre>
</li>
<li>
Show the name, type and location on the stack frame of local variables,
arguments and return values:
<pre>(gdb) <b>info locals</b>
(gdb) <b>info args</b>
(gdb) <b>p variable</b>
(gdb) <b>whatis variable</b></pre>
</li>
<li>
Show the name, type and location of global variables:
<pre>(gdb) <b>info variables <i>regexp</i></b></pre>
</li>
</ul>
</div>

<ul>
<li>
为代码显示文件与行号，设置断点并反汇编：
<pre>(gdb) <b>list</b>
(gdb) <b>list <i>line</i></b>
(gdb) <b>list <i>file.go</i>:<i>line</i></b>
(gdb) <b>break <i>line</i></b>
(gdb) <b>break <i>file.go</i>:<i>line</i></b>
(gdb) <b>disas</b></pre>
</li>
<li>
显示回溯并展开栈帧：
<pre>(gdb) <b>bt</b>
(gdb) <b>frame <i>n</i></b></pre>
</li>
<li>
显示本地变量、实参与返回值的栈帧上的名字、类型与位置：
<pre>(gdb) <b>info locals</b>
(gdb) <b>info args</b>
(gdb) <b>p variable</b>
(gdb) <b>whatis variable</b></pre>
</li>
<li>
显示全局变量的名字、类型与位置：
<pre>(gdb) <b>info variables <i>regexp</i></b></pre>
</li>
</ul>

<div class="english">
<h3 id="Go_Extensions">Go Extensions</h3>
</div>

<h3 id="Go扩展">Go 扩展</h3>

<div class="english">
<p>
A recent extension mechanism to GDB allows it to load extension scripts for a
given binary. The tool chain uses this to extend GDB with a handful of
commands to inspect internals of the runtime code (such as goroutines) and to
pretty print the built-in map, slice and channel types.
</p>
</div>

<p>
GDB 最近的一个扩展机制允许它为给定的二进制文件加载扩展脚本。工具链以此用少数命令来扩展 GDB，
检查运行时代码的内部构件（例如 Go 程），并美观打印出内建映射、切片与信道类型。
</p>

<div class="english">
<ul>
<li>
Pretty printing a string, slice, map, channel or interface:
<pre>(gdb) <b>p <i>var</i></b></pre>
</li>
<li>
A $len() and $cap() function for strings, slices and maps:
<pre>(gdb) <b>p $len(<i>var</i>)</b></pre>
</li>
<li>
A function to cast interfaces to their dynamic types:
<pre>(gdb) <b>p $dtype(<i>var</i>)</b>
(gdb) <b>iface <i>var</i></b></pre>
<p class="detail"><b>Known issue:</b> GDB can’t automatically find the dynamic
type of an interface value if its long name differs from its short name
(annoying when printing stacktraces, the pretty printer falls back to printing
the short type name and a pointer).</p>
</li>
<li>
Inspecting goroutines:
<pre>(gdb) <b>info goroutines</b>
(gdb) <b>goroutine <i>n</i> <i>cmd</i></b>
(gdb) <b>help goroutine</b></pre>
For example:
<pre>(gdb) <b>goroutine 12 bt</b></pre>
</li>
</ul>
</div>

<ul>
<li>
美观打印出一个字符串、切片、映射、信道或接口：
<pre>(gdb) <b>p <i>var</i></b></pre>
</li>
<li>
用于字符串、切片与映射的 $len() 与 $cap() 函数：
<pre>(gdb) <b>p $len(<i>var</i>)</b></pre>
</li>
<li>
函数将接口抛至其动态类型：
<pre>(gdb) <b>p $dtype(<i>var</i>)</b>
(gdb) <b>iface <i>var</i></b></pre>
<p class="detail"><b>已知问题：</b> 若接口值的长名与短名不同，GDB将无法自动找到其动态类型
（很讨厌在打印栈跟踪时，美观打印回退至短类型名与一个指针）。</p>
</li>
<li>
检查Go程：
<pre>(gdb) <b>info goroutines</b>
(gdb) <b>goroutine <i>n</i> <i>cmd</i></b>
(gdb) <b>help goroutine</b></pre>
例如：
<pre>(gdb) <b>goroutine 12 bt</b></pre>
</li>
</ul>

<div class="english">
<p>
If you'd like to see how this works, or want to extend it, take a look at <a
href="/src/runtime/runtime-gdb.py">src/runtime/runtime-gdb.py</a> in
the Go source distribution. It depends on some special magic types
(<code>hash&lt;T,U&gt;</code>) and variables (<code>runtime.m</code> and
<code>runtime.g</code>) that the linker
(<a href="/src/cmd/link/internal/ld/dwarf.go">src/cmd/link/internal/ld/dwarf.go</a>) ensures are described in
the DWARF code.
</p>
</div>

<p>
如果你想看看它如何工作，或者想要扩展它，那就看看Go源码发行版中的
<a href="/src/pkg/runtime/runtime-gdb.py">src/pkg/runtime/runtime-gdb.py</a>吧。
连接器依赖于一些特别的魔法类型（<code>hash&lt;T,U&gt;</code>）与变量（<code>runtime.m</code>
与 <code>runtime.g</code>）来确保以DWARF码描述（<a href="/src/cmd/ld/dwarf.c">src/cmd/ld/dwarf.c</a>）。
</p>

<div class="english">
<p>
If you're interested in what the debugging information looks like, run
'<code>objdump -W 6.out</code>' and browse through the <code>.debug_*</code>
sections.
</p>
</div>

<p>
如果你对调试信息看起来如何感兴趣，运行 '<code>objdump -W 6.out</code>' 并翻阅
<code>.debug_*</code> 的小节。
</p>


<div class="english">
<h3 id="Known_Issues">Known Issues</h3>
</div>

<h3 id="已知问题">已知问题</h3>

<div class="english">
<ol>
<li>String pretty printing only triggers for type string, not for types derived
from it.</li>
<li>Type information is missing for the C parts of the runtime library.</li>
<li>GDB does not understand Go’s name qualifications and treats
<code>"fmt.Print"</code> as an unstructured literal with a <code>"."</code>
that needs to be quoted.  It objects even more strongly to method names of
the form <code>pkg.(*MyType).Meth</code>.
<li>All global variables are lumped into package <code>"main"</code>.</li>
</ol>
</div>

<ol>
<li>字符串的美观打印只会为类型string触发，而不会为从它衍生出的类型触发。</li>
<li>运行时库C部分的类型信息缺失。</li>
<li>GDB不理解Go的名称限定且将 <code>"fmt.Print"</code> 作为需要引用的带 <code>"."</code>
的无结构字面来对待。该对象甚至比 <code>pkg.(*MyType).Meth</code> 形式的方法名更强。
<li>所有全局变量都集中在包 <code>"main"</code> 中。</li>
</ol>


<div class="english">
<h2 id="Tutorial">Tutorial</h2>
</div>

<h2 id="教程">教程</h2>

<div class="english">
<p>
In this tutorial we will inspect the binary of the
<a href="/pkg/regexp/">regexp</a> package's unit tests. To build the binary,
change to <code>$GOROOT/src/regexp</code> and run <code>go test -c</code>.
This should produce an executable file named <code>regexp.test</code>.
</p>
</div>

<p>
在此教程中，我们将检查 <a href="/pkg/regexp/">regexp</a> 包单元测试的二进制文件。
要构建此二进制文件，切换到 <code>$GOROOT/src/pkg/regexp</code> 目录并运行
<code>go test -c</code>。这将产生一个名为 <code>regexp.test</code> 的可执行文件。
</p>


<div class="english">
<h3 id="Getting_Started">Getting Started</h3>
</div>

<h3 id="起步">起步</h3>

<div class="english">
<p>
Launch GDB, debugging <code>regexp.test</code>:
</p>
</div>

<p>
启动GDB，调试 <code>regexp.test</code>：
</p>

<pre>
$ <b>gdb regexp.test</b>
GNU gdb (GDB) 7.2-gg8
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv  3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
Type "show copying" and "show warranty" for licensing/warranty details.
This GDB was configured as "x86_64-linux".

Reading symbols from  /home/user/go/src/regexp/regexp.test...
done.
Loading Go Runtime support.
(gdb)
</pre>

<div class="english">
<p>
The message <code>"Loading Go Runtime support"</code> means that GDB loaded the
extension from <code>$GOROOT/src/runtime/runtime-gdb.py</code>.
</p>
</div>

<p>
信息 <code>"Loading Go Runtime support"</code> 意为 GDB 从
<code>$GOROOT/src/pkg/runtime/runtime-gdb.py</code> 加载扩展。
</p>

<div class="english">
<p>
To help GDB find the Go runtime sources and the accompanying support script,
pass your <code>$GOROOT</code> with the <code>'-d'</code> flag:
</p>
</div>

<p>
要帮助 GDB 找到 Go 运行时源及其伴随的支持脚本，请将你的 <code>$GOROOT</code> 通过
<code>'-d'</code> 标记传入：
</p>

<pre>
$ <b>gdb regexp.test -d $GOROOT</b>
</pre>

<div class="english">
<p>
If for some reason GDB still can't find that directory or that script, you can load
it by hand by telling gdb (assuming you have the go sources in
<code>~/go/</code>):
</p>
</div>

<p>
若因为一些原因 GDB 仍然不能找到该目录或该脚本，你可以通过手动告诉 gdb 来加载它
（假定你在 <code>~/go/</code> 中拥有 go 源码）。
</p>

<pre>
(gdb) <b>source ~/go/src/runtime/runtime-gdb.py</b>
Loading Go Runtime support.
</pre>


<div class="english">
<h3 id="Inspecting_the_source">Inspecting the source</h3>
</div>

<h3 id="检查源码">检查源码</h3>

<div class="english">
<p>
Use the <code>"l"</code> or <code>"list"</code> command to inspect source code.
</p>
</div>

<p>
使用 <code>"l"</code> 或 <code>"list"</code> 命令来检查源码。
</p>

<pre>
(gdb) <b>l</b>
</pre>

<div class="english">
<p>
List a specific part of the source parametrizing <code>"list"</code> with a
function name (it must be qualified with its package name).
</p>
</div>

<p>
通过函数名（它必须由其包名所限定）来列出由参数 <code>"list"</code> 确定的源的指定部分。
</p>

<pre>
(gdb) <b>l main.main</b>
</pre>

<div class="english">
<p>
List a specific file and line number:
</p>
</div>

<p>
列出指定的文件与行号：
</p>

<pre>
(gdb) <b>l regexp.go:1</b>
(gdb) <i># Hit enter to repeat last command. Here, this lists next 10 lines.</i>
</pre>


<div class="english">
<h3 id="Naming">Naming</h3>
</div>

<h3 id="命名">命名</h3>

<div class="english">
<p>
Variable and function names must be qualified with the name of the packages
they belong to. The <code>Compile</code> function from the <code>regexp</code>
package is known to GDB as <code>'regexp.Compile'</code>.
</p>
</div>

<p>
变量与函数名必须由它们所属的包名限定。来自 <code>regexp</code> 包的
<code>Compile</code> 函数被 GDB 视作 <code>'regexp.Compile'</code>。
</p>

<div class="english">
<p>
Methods must be qualified with the name of their receiver types. For example,
the <code>*Regexp</code> type’s <code>String</code> method is known as
<code>'regexp.(*Regexp).String'</code>.
</p>
</div>

<p>
方法必须由其接收器类型的名字限定。例如，<code>*Regexp</code> 类型的 <code>String</code>
方法应视作 <code>'regexp.(*Regexp).String'</code>。
</p>

<div class="english">
<p>
Variables that shadow other variables are magically suffixed with a number in the debug info.
Variables referenced by closures will appear as pointers magically prefixed with '&amp;'.
</p>
</div>

<p>
尾随其他变量的变量会魔法般地后缀一些调试信息。通过闭包引用的变量将作为指针魔法般地前缀 '&amp;'。
</p>

<div class="english">
<h3 id="Setting_breakpoints">Setting breakpoints</h3>
</div>

<h3 id="设置断点">设置断点</h3>

<div class="english">
<p>
Set a breakpoint at the <code>TestFind</code> function:
</p>
</div>

<p>
在 <code>TestFind</code> 函数处设置断点：
</p>

<pre>
(gdb) <b>b 'regexp.TestFind'</b>
Breakpoint 1 at 0x424908: file /home/user/go/src/regexp/find_test.go, line 148.
</pre>

<div class="english">
<p>
Run the program:
</p>
</div>

<p>
运行此程序
</p>

<pre>
(gdb) <b>run</b>
Starting program: /home/user/go/src/regexp/regexp.test

Breakpoint 1, regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148
148	func TestFind(t *testing.T) {
</pre>

<div class="english">
<p>
Execution has paused at the breakpoint.
See which goroutines are running, and what they're doing:
</p>
</div>

<p>
执行会在断点处暂停。看看哪个 Go 程正在运行，以及它们在做什么：
</p>

<pre>
(gdb) <b>info goroutines</b>
  1  waiting runtime.gosched
* 13  running runtime.goexit
</pre>

<div class="english">
<p>
the one marked with the <code>*</code> is the current goroutine.
</p>
</div>

<p>
以 <code>*</code> 标记的为当前 Go 程。
</p>

<div class="english">
<h3 id="Inspecting_the_stack">Inspecting the stack</h3>
</div>

<h3 id="检查栈">检查栈</h3>

<div class="english">
<p>
Look at the stack trace for where we’ve paused the program:
</p>
</div>

<p>
看一下我们所暂停程序的栈跟踪：
</p>

<pre>
(gdb) <b>bt</b>  <i># backtrace</i>
#0  regexp.TestFind (t=0xf8404a89c0) at /home/user/go/src/regexp/find_test.go:148
#1  0x000000000042f60b in testing.tRunner (t=0xf8404a89c0, test=0x573720) at /home/user/go/src/testing/testing.go:156
#2  0x000000000040df64 in runtime.initdone () at /home/user/go/src/runtime/proc.c:242
#3  0x000000f8404a89c0 in ?? ()
#4  0x0000000000573720 in ?? ()
#5  0x0000000000000000 in ?? ()
</pre>

<div class="english">
<p>
The other goroutine, number 1, is stuck in <code>runtime.gosched</code>, blocked on a channel receive:
</p>
</div>

<p>
另一个Go程#1卡在 <code>runtime.gosched</code> 中，阻塞在信道接收上：
</p>

<pre>
(gdb) <b>goroutine 1 bt</b>
#0  0x000000000040facb in runtime.gosched () at /home/user/go/src/runtime/proc.c:873
#1  0x00000000004031c9 in runtime.chanrecv (c=void, ep=void, selected=void, received=void)
 at  /home/user/go/src/runtime/chan.c:342
#2  0x0000000000403299 in runtime.chanrecv1 (t=void, c=void) at/home/user/go/src/runtime/chan.c:423
#3  0x000000000043075b in testing.RunTests (matchString={void (struct string, struct string, bool *, error *)}
 0x7ffff7f9ef60, tests=  []testing.InternalTest = {...}) at /home/user/go/src/testing/testing.go:201
#4  0x00000000004302b1 in testing.Main (matchString={void (struct string, struct string, bool *, error *)}
 0x7ffff7f9ef80, tests= []testing.InternalTest = {...}, benchmarks= []testing.InternalBenchmark = {...})
at /home/user/go/src/testing/testing.go:168
#5  0x0000000000400dc1 in main.main () at /home/user/go/src/regexp/_testmain.go:98
#6  0x00000000004022e7 in runtime.mainstart () at /home/user/go/src/runtime/amd64/asm.s:78
#7  0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243
#8  0x0000000000000000 in ?? ()
</pre>

<div class="english">
<p>
The stack frame shows we’re currently executing the <code>regexp.TestFind</code> function, as expected.
</p>
</div>

<p>
果然，栈帧显示当前我们正在执行 <code>regexp.TestFind</code> 函数。
</p>

<pre>
(gdb) <b>info frame</b>
Stack level 0, frame at 0x7ffff7f9ff88:
 rip = 0x425530 in regexp.TestFind (/home/user/go/src/regexp/find_test.go:148);
    saved rip 0x430233
 called by frame at 0x7ffff7f9ffa8
 source language minimal.
 Arglist at 0x7ffff7f9ff78, args: t=0xf840688b60
 Locals at 0x7ffff7f9ff78, Previous frame's sp is 0x7ffff7f9ff88
 Saved registers:
  rip at 0x7ffff7f9ff80
</pre>

<div class="english">
<p>
The command <code>info locals</code> lists all variables local to the function and their values, but is a bit
dangerous to use, since it will also try to print uninitialized variables. Uninitialized slices may cause gdb to try
to print arbitrary large arrays.
</p>
</div>

<p>
命令 <code>info locals</code>
列出所有该函数及其值的本地变量，但用它会有点儿危险，因为它还会试图打印未初始化变量。
未初始化切片可能导致gdb试图打印任意大的数组。
</p>

<div class="english">
<p>
The function’s arguments:
</p>
</div>

<p>
函数实参：
</p>

<pre>
(gdb) <b>info args</b>
t = 0xf840688b60
</pre>

<div class="english">
<p>
When printing the argument, notice that it’s a pointer to a
<code>Regexp</code> value. Note that GDB has incorrectly put the <code>*</code>
on the right-hand side of the type name and made up a 'struct' keyword, in traditional C style.
</p>
</div>

<p>
在打印该实参时，注意它是指向 <code>Regexp</code> 值的指针。另外请注意GDB错误地将 <code>*</code>
放在了类型名的右边，并按照传统的 C 风格添加了 <code>'struct'</code> 关键字。
</p>

<pre>
(gdb) <b>p re</b>
(gdb) p t
$1 = (struct testing.T *) 0xf840688b60
(gdb) p t
$1 = (struct testing.T *) 0xf840688b60
(gdb) p *t
$2 = {errors = "", failed = false, ch = 0xf8406f5690}
(gdb) p *t-&gt;ch
$3 = struct hchan&lt;*testing.T&gt;
</pre>

<div class="english">
<p>
That <code>struct hchan&lt;*testing.T&gt;</code> is the runtime-internal representation of a channel.  It is currently empty, or gdb would have pretty-printed it's contents.
</p>
</div>

<p>
其中 <code>struct hchan&lt;*testing.T&gt;</code> 为信道的运行时内部表示。它一般不是为空就是gdb会美观打印其内容。
</p>

<div class="english">
<p>
Stepping forward:
</p>
</div>

<p>
下一步：
</p>

<pre>
(gdb) <b>n</b>  <i># execute next line</i>
149             for _, test := range findTests {
(gdb)    <i># enter is repeat</i>
150                     re := MustCompile(test.pat)
(gdb) <b>p test.pat</b>
$4 = ""
(gdb) <b>p re</b>
$5 = (struct regexp.Regexp *) 0xf84068d070
(gdb) <b>p *re</b>
$6 = {expr = "", prog = 0xf840688b80, prefix = "", prefixBytes =  []uint8, prefixComplete = true,
  prefixRune = 0, cond = 0 '\000', numSubexp = 0, longest = false, mu = {state = 0, sema = 0},
  machine =  []*regexp.machine}
(gdb) <b>p *re->prog</b>
$7 = {Inst =  []regexp/syntax.Inst = {{Op = 5 '\005', Out = 0, Arg = 0, Rune =  []int}, {Op =
    6 '\006', Out = 2, Arg = 0, Rune =  []int}, {Op = 4 '\004', Out = 0, Arg = 0, Rune =  []int}},
  Start = 1, NumCap = 2}
</pre>


<div class="english">
<p>
We can step into the <code>String</code>function call with <code>"s"</code>:
</p>
</div>

<p>
我们可以步进至 <code>String</code> 函数调用 <code>"s"</code>：
</p>

<pre>
(gdb) <b>s</b>
regexp.(*Regexp).String (re=0xf84068d070, noname=void) at /home/user/go/src/regexp/regexp.go:97
97      func (re *Regexp) String() string {
</pre>

<div class="english">
<p>
Get a stack trace to see where we are:
</p>
</div>

<p>
看看栈跟踪我们在哪儿：
</p>

<pre>
(gdb) <b>bt</b>
#0  regexp.(*Regexp).String (re=0xf84068d070, noname=void)
    at /home/user/go/src/regexp/regexp.go:97
#1  0x0000000000425615 in regexp.TestFind (t=0xf840688b60)
    at /home/user/go/src/regexp/find_test.go:151
#2  0x0000000000430233 in testing.tRunner (t=0xf840688b60, test=0x5747b8)
    at /home/user/go/src/testing/testing.go:156
#3  0x000000000040ea6f in runtime.initdone () at /home/user/go/src/runtime/proc.c:243
....
</pre>

<div class="english">
<p>
Look at the source code:
</p>
</div>

<p>
查看源码：
</p>

<pre>
(gdb) <b>l</b>
92              mu      sync.Mutex
93              machine []*machine
94      }
95
96      // String returns the source text used to compile the regular expression.
97      func (re *Regexp) String() string {
98              return re.expr
99      }
100
101     // Compile parses a regular expression and returns, if successful,
</pre>

<div class="english">
<h3 id="Pretty_Printing">Pretty Printing</h3>
</div>

<h3 id="美观打印">美观打印</h3>

<div class="english">
<p>
GDB's pretty printing mechanism is triggered by regexp matches on type names.  An example for slices:
</p>
</div>

<p>
GDB 的美观打印机制由类型名的正则匹配触发。一个切片的例子：
</p>

<pre>
(gdb) <b>p utf</b>
$22 =  []uint8 = {0 '\000', 0 '\000', 0 '\000', 0 '\000'}
</pre>

<div class="english">
<p>
Since slices, arrays and strings are not C pointers, GDB can't interpret the subscripting operation for you, but
you can look inside the runtime representation to do that (tab completion helps here):
</p>
</div>

<p>
由于切片、数组及字符串并非 C 指针，GDB 无法为你解释下标操作，不过你可以查看运行时中的表示来达到目的（tab 补全可以帮你）：
</p>

<pre>
(gdb) <b>p slc</b>
$11 =  []int = {0, 0}
(gdb) <b>p slc-&gt;</b><i>&lt;TAB&gt;</i>
array  slc    len
(gdb) <b>p slc->array</b>
$12 = (int *) 0xf84057af00
(gdb) <b>p slc->array[1]</b>
$13 = 0
</pre>

<div class="english">
<p>
The extension functions $len and $cap work on strings, arrays and slices:
</p>
</div>

<p>
扩展函数 $len 与 $cap 作用于字符串、数组及切片：
</p>

<pre>
(gdb) <b>p $len(utf)</b>
$23 = 4
(gdb) <b>p $cap(utf)</b>
$24 = 4
</pre>

<div class="english">
<p>
Channels and maps are 'reference' types, which gdb shows as pointers to C++-like types <code>hash&lt;int,string&gt;*</code>.  Dereferencing will trigger prettyprinting
</p>
</div>

<p>
信道与映射为“引用”类型，gdb 会将它作为指向类 C++ 类型 <code>hash&lt;int,string&gt;*</code> 的指针来显示。
解引用将触发美观打印。
</p>

<div class="english">
<p>
Interfaces are represented in the runtime as a pointer to a type descriptor and a pointer to a value.  The Go GDB runtime extension decodes this and automatically triggers pretty printing for the runtime type.  The extension function <code>$dtype</code> decodes the dynamic type for you (examples are taken from a breakpoint at <code>regexp.go</code> line 293.)
</p>
</div>

<p>
接口在运行时会表示为一个指向类型描述符的指针与一个指向值的指针。Go 的 GDB
运行时扩展可将其解码并为该运行时类型自动触发美观打印。扩展函数 <code>$dtype</code> 可为你解码动态类型。
（例子从 <code>regexp.go</code> 第 293 行的断点处获取。）
</p>

<pre>
(gdb) <b>p i</b>
$4 = {str = "cbb"}
(gdb) <b>whatis i</b>
type = regexp.input
(gdb) <b>p $dtype(i)</b>
$26 = (struct regexp.inputBytes *) 0xf8400b4930
(gdb) <b>iface i</b>
regexp.input: struct regexp.inputBytes *
</pre>
